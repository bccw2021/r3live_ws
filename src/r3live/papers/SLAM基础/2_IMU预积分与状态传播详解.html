<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMU预积分与状态传播详解</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --primary: #3498db;
            --secondary: #2ecc71;
            --accent: #9b59b6;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --danger: #e74c3c;
            --warning: #f39c12;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, var(--dark), var(--primary));
            color: white;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
            transform: rotate(30deg);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            position: relative;
        }
        
        .subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }
        
        .nav-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            background: white;
            border-radius: 50px;
            padding: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .nav-btn {
            padding: 14px 35px;
            background: none;
            border: none;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.4s ease;
            position: relative;
            z-index: 1;
        }
        
        .nav-btn.active {
            color: white;
            background: var(--primary);
            box-shadow: 0 4px 10px rgba(52, 152, 219, 0.4);
        }
        
        .card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            padding: 30px;
            margin-bottom: 30px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border-left: 4px solid var(--primary);
            position: relative;
            overflow: hidden;
        }
        
        .card:hover {
            transform: translateY(-7px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.12);
        }
        
        .card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
        }
        
        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--light);
        }
        
        .card-icon {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 20px;
            color: white;
            font-size: 1.8rem;
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
        }
        
        .card-title {
            font-size: 1.8rem;
            color: var(--dark);
            font-weight: 700;
        }
        
        .section-title {
            font-size: 1.5rem;
            color: var(--primary);
            margin: 25px 0 15px;
            padding-bottom: 10px;
            border-bottom: 2px dashed #e0e6ed;
        }
        
        .content-container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            margin: 25px 0;
        }
        
        .math-formula {
            flex: 1;
            min-width: 300px;
            background: #f9fbfd;
            padding: 25px;
            border-radius: 12px;
            border-left: 4px solid var(--accent);
            box-shadow: inset 4px 0 0 var(--accent), 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .math-formula h3 {
            color: var(--accent);
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        
        .variable-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .variable-table th, 
        .variable-table td {
            padding: 16px 20px;
            text-align: left;
            border-bottom: 1px solid #eef1f5;
        }
        
        .variable-table th {
            background: linear-gradient(135deg, var(--dark), #34495e);
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .variable-table tr:nth-child(even) {
            background-color: #f8fafc;
        }
        
        .variable-table tr:hover {
            background-color: #eef7ff;
        }
        
        .derivation-steps {
            background: #f8fafc;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border-left: 4px solid var(--secondary);
            box-shadow: inset 4px 0 0 var(--secondary), 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .step {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px dashed #dce4ec;
        }
        
        .step:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .step-number {
            display: inline-block;
            width: 32px;
            height: 32px;
            background: var(--secondary);
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 32px;
            font-weight: bold;
            margin-right: 12px;
        }
        
        .step-title {
            display: inline;
            font-size: 1.3rem;
            color: var(--dark);
        }
        
        .diagram {
            flex: 1;
            min-width: 300px;
            height: 350px;
            background: #f8fafc;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .footer {
            text-align: center;
            padding: 30px;
            margin-top: 40px;
            color: #7f8c8d;
            border-top: 1px solid #e0e6ed;
            font-size: 1.1rem;
        }
        
        @media (max-width: 768px) {
            .content-container {
                flex-direction: column;
            }
            
            .nav-tabs {
                flex-direction: column;
                border-radius: 15px;
            }
            
            .nav-btn {
                width: 100%;
                border-radius: 0;
            }
            
            header {
                padding: 20px 15px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
        }
        
        .highlight {
            background: linear-gradient(120deg, rgba(52, 152, 219, 0.15), rgba(46, 204, 113, 0.15));
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .key-concept {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid var(--warning);
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>IMU预积分与状态传播</h1>
            <p class="subtitle">深入解析惯性测量单元在SLAM系统中的数学原理、推导过程与实现方法</p>
        </header>
        
        <div class="nav-tabs">
            <button class="nav-btn active">基本原理</button>
            <button class="nav-btn">状态传播</button>
            <button class="nav-btn">预积分推导</button>
            <button class="nav-btn">误差分析</button>
        </div>
        
        <div class="card">
            <div class="card-header">
                <div class="card-icon">∫</div>
                <h2 class="card-title">IMU预积分核心概念</h2>
            </div>
            
            <p>IMU（惯性测量单元）是SLAM系统中关键传感器之一，提供高频的角速度和加速度测量。IMU预积分技术通过累积一段时间内的IMU测量值，计算相对运动量，避免在优化过程中重复积分，大大提高了计算效率。</p>
            
            <div class="key-concept">
                <h3 class="section-title">为什么需要预积分？</h3>
                <p>在基于滤波或优化的SLAM系统中，状态向量通常包含位置、速度、方向等变量。当新的IMU数据到达时，需要更新状态估计。传统方法需要从初始状态开始重新积分所有IMU数据，计算量大。预积分技术将两个关键帧之间的IMU测量值预先积分，得到一个相对运动增量，与绝对位姿解耦，优化时只需更新相对增量。</p>
            </div>
            
            <h3 class="section-title">关键变量定义</h3>
            
            <table class="variable-table">
                <thead>
                    <tr>
                        <th>变量</th>
                        <th>符号</th>
                        <th>描述</th>
                        <th>维度</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>位置</td>
                        <td>\(\mathbf{p}\)</td>
                        <td>在全局坐标系中的位置</td>
                        <td>3×1</td>
                    </tr>
                    <tr>
                        <td>速度</td>
                        <td>\(\mathbf{v}\)</td>
                        <td>在全局坐标系中的速度</td>
                        <td>3×1</td>
                    </tr>
                    <tr>
                        <td>旋转矩阵</td>
                        <td>\(\mathbf{R}\)</td>
                        <td>从机体坐标系到世界坐标系的旋转</td>
                        <td>3×3</td>
                    </tr>
                    <tr>
                        <td>加速度偏置</td>
                        <td>\(\mathbf{b}_a\)</td>
                        <td>加速度计的偏置误差</td>
                        <td>3×1</td>
                    </tr>
                    <tr>
                        <td>陀螺仪偏置</td>
                        <td>\(\mathbf{b}_g\)</td>
                        <td>陀螺仪的偏置误差</td>
                        <td>3×1</td>
                    </tr>
                    <tr>
                        <td>角速度测量</td>
                        <td>\(\tilde{\boldsymbol{\omega}}\)</td>
                        <td>IMU测量的角速度值</td>
                        <td>3×1</td>
                    </tr>
                    <tr>
                        <td>加速度测量</td>
                        <td>\(\tilde{\mathbf{a}}\)</td>
                        <td>IMU测量的加速度值</td>
                        <td>3×1</td>
                    </tr>
                    <tr>
                        <td>预积分位置</td>
                        <td>\(\boldsymbol{\alpha}_{ij}\)</td>
                        <td>从时刻i到j的位置变化量</td>
                        <td>3×1</td>
                    </tr>
                    <tr>
                        <td>预积分速度</td>
                        <td>\(\boldsymbol{\beta}_{ij}\)</td>
                        <td>从时刻i到j的速度变化量</td>
                        <td>3×1</td>
                    </tr>
                    <tr>
                        <td>预积分旋转</td>
                        <td>\(\boldsymbol{\gamma}_{ij}\)</td>
                        <td>从时刻i到j的旋转变化量</td>
                        <td>3×3</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="card">
            <div class="card-header">
                <div class="card-icon">∇</div>
                <h2 class="card-title">IMU预积分完整数学推导</h2>
            </div>
            
            <div class="math-formula">
                <h3>1. 连续时间IMU动力学模型</h3>
                <p>IMU在连续时间域的动力学方程为：</p>
                <p>$$\begin{align}
                \dot{\mathbf{p}}^w &= \mathbf{v}^w \\
                \dot{\mathbf{v}}^w &= \mathbf{R}^w_b(\mathbf{a}^b - \mathbf{b}_a - \mathbf{n}_a) + \mathbf{g}^w \\
                \dot{\mathbf{R}}^w_b &= \mathbf{R}^w_b[\boldsymbol{\omega}^b - \mathbf{b}_g - \mathbf{n}_g]_{\times} \\
                \dot{\mathbf{b}}_a &= \mathbf{n}_{ba} \\
                \dot{\mathbf{b}}_g &= \mathbf{n}_{bg}
                \end{align}$$</p>
                <p>其中：</p>
                <ul>
                    <li>\(\mathbf{p}^w, \mathbf{v}^w\) - 世界坐标系下的位置和速度</li>
                    <li>\(\mathbf{R}^w_b\) - 从机体坐标系到世界坐标系的旋转矩阵</li>
                    <li>\(\mathbf{a}^b, \boldsymbol{\omega}^b\) - 机体坐标系下的加速度和角速度测量值</li>
                    <li>\(\mathbf{b}_a, \mathbf{b}_g\) - 加速度计和陀螺仪的偏置</li>
                    <li>\(\mathbf{n}_a, \mathbf{n}_g\) - 测量噪声</li>
                    <li>\(\mathbf{g}^w\) - 重力加速度</li>
                </ul>
            </div>
            
            <div class="math-formula">
                <h3>2. 预积分量的定义与推导</h3>
                <p>定义从时刻$i$到时刻$j$的预积分量：</p>
                <p>$$\begin{align}
                \boldsymbol{\alpha}_{ij} &= \iint_{t \in [t_i, t_j]} \mathbf{R}^T_i(\mathbf{a}^b_t - \mathbf{b}_{a_i}) dt^2 \\
                \boldsymbol{\beta}_{ij} &= \int_{t \in [t_i, t_j]} \mathbf{R}^T_i(\mathbf{a}^b_t - \mathbf{b}_{a_i}) dt \\
                \boldsymbol{\gamma}_{ij} &= \prod_{t \in [t_i, t_j]} \text{Exp}((\boldsymbol{\omega}^b_t - \mathbf{b}_{g_i}) dt)
                \end{align}$$</p>
                <p><strong>物理意义：</strong></p>
                <ul>
                    <li>\(\boldsymbol{\alpha}_{ij}\) - 相对位移（在初始坐标系\(i\)中表示）</li>
                    <li>\(\boldsymbol{\beta}_{ij}\) - 相对速度（在初始坐标系\(i\)中表示）</li>
                    <li>\(\boldsymbol{\gamma}_{ij}\) - 相对旋转（从坐标系\(i\)到坐标系\(j\)）</li>
                </ul>
            </div>
            
            <div class="math-formula">
                <h3>3. 离散化递推公式</h3>
                <p>在实际实现中，采用中点积分法进行离散化：</p>
                <p>$$\begin{align}
                \boldsymbol{\alpha}_{i,k+1} &= \boldsymbol{\alpha}_{ik} + \boldsymbol{\beta}_{ik}\Delta t + \frac{1}{2}\mathbf{R}_i\hat{\mathbf{a}}_k\Delta t^2 \\
                \boldsymbol{\beta}_{i,k+1} &= \boldsymbol{\beta}_{ik} + \mathbf{R}_i\hat{\mathbf{a}}_k\Delta t \\
                \boldsymbol{\gamma}_{i,k+1} &= \boldsymbol{\gamma}_{ik} \cdot \text{Exp}(\hat{\boldsymbol{\omega}}_k\Delta t)
                \end{align}$$</p>
                <p>其中：</p>
                <p>$$\begin{align}
                \hat{\mathbf{a}}_k &= \frac{1}{2}(\mathbf{a}_k + \mathbf{a}_{k+1}) - \mathbf{b}_{a_i} \\
                \hat{\boldsymbol{\omega}}_k &= \frac{1}{2}(\boldsymbol{\omega}_k + \boldsymbol{\omega}_{k+1}) - \mathbf{b}_{g_i}
                \end{align}$$</p>
            </div>
            
            <div class="math-formula">
                <h3>4. 预积分约束方程</h3>
                <p>利用预积分量建立的约束方程：</p>
                <p>$$\begin{align}
                \mathbf{p}_j &= \mathbf{p}_i + \mathbf{v}_i \Delta t_{ij} + \frac{1}{2}\mathbf{g}\Delta t_{ij}^2 + \mathbf{R}_i \boldsymbol{\alpha}_{ij} \\
                \mathbf{v}_j &= \mathbf{v}_i + \mathbf{g}\Delta t_{ij} + \mathbf{R}_i \boldsymbol{\beta}_{ij} \\
                \mathbf{R}_j &= \mathbf{R}_i \boldsymbol{\gamma}_{ij}
                \end{align}$$</p>
                <p>这些约束方程将两个关键帧的状态通过预积分量联系起来，避免了在优化过程中重复积分IMU数据。</p>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <div class="card-icon">ẋ</div>
                <h2 class="card-title">状态传播模型</h2>
            </div>
            
            <p>状态传播描述了系统状态如何随时间演变，基于IMU的测量值。我们首先建立连续时间模型，然后推导离散时间实现。</p>
            
            <h3 class="section-title">连续时间运动学模型</h3>
            
            <div class="content-container">
                <div class="math-formula">
                    <h3>状态向量定义</h3>
                    <p>\[
                    \mathbf{x} = \left[ \mathbf{p}^T, \mathbf{v}^T, \mathbf{R}, \mathbf{b}_a^T, \mathbf{b}_g^T \right]^T
                    \]</p>
                    
                    <h3>运动学微分方程</h3>
                    <p>\[
                    \begin{cases}
                    \dot{\mathbf{p}} = \mathbf{v} \\
                    \dot{\mathbf{v}} = \mathbf{R} (\tilde{\mathbf{a}} - \mathbf{b}_a - \boldsymbol{\eta}_a) + \mathbf{g} \\
                    \dot{\mathbf{R}} = \mathbf{R} (\tilde{\boldsymbol{\omega}} - \mathbf{b}_g - \boldsymbol{\eta}_g)_\times \\
                    \dot{\mathbf{b}}_a = \boldsymbol{\eta}_{ba} \\
                    \dot{\mathbf{b}}_g = \boldsymbol{\eta}_{bg}
                    \end{cases}
                    \]</p>
                    
                    <p>其中：</p>
                    <ul>
                        <li>\(\mathbf{g}\) 是重力向量</li>
                        <li>\((\cdot)_\times\) 表示向量对应的反对称矩阵</li>
                        <li>\(\boldsymbol{\eta}_a, \boldsymbol{\eta}_g\) 是测量噪声</li>
                        <li>\(\boldsymbol{\eta}_{ba}, \boldsymbol{\eta}_{bg}\) 是偏置随机游走噪声</li>
                    </ul>
                </div>
                
                <div class="diagram" id="state-propagation">
                    <canvas id="stateCanvas" width="500" height="350"></canvas>
                </div>
            </div>
            
            <div class="derivation-steps">
                <h3 class="section-title">离散时间状态传播推导</h3>
                
                <div class="step">
                    <div class="step-number">1</div>
                    <h3 class="step-title">旋转积分</h3>
                    <p>对于旋转矩阵，使用指数映射进行积分：</p>
                    <p>\[
                    \mathbf{R}_{k+1} = \mathbf{R}_k \cdot \exp\left((\tilde{\boldsymbol{\omega}}_k - \mathbf{b}_{g,k} - \boldsymbol{\eta}_{g,k}) \Delta t\right)
                    \]</p>
                    <p>其中 \(\exp(\cdot)\) 是SO(3)指数映射，将角速度向量转换为旋转矩阵。</p>
                </div>
                
                <div class="step">
                    <div class="step-number">2</div>
                    <h3 class="step-title">速度积分</h3>
                    <p>速度积分需要考虑旋转后的加速度和重力：</p>
                    <p>\[
                    \mathbf{v}_{k+1} = \mathbf{v}_k + \left[ \mathbf{R}_k (\tilde{\mathbf{a}}_k - \mathbf{b}_{a,k} - \boldsymbol{\eta}_{a,k}) + \mathbf{g} \right] \Delta t
                    \]</p>
                </div>
                
                <div class="step">
                    <div class="step-number">3</div>
                    <h3 class="step-title">位置积分</h3>
                    <p>位置通过对速度积分得到：</p>
                    <p>\[
                    \mathbf{p}_{k+1} = \mathbf{p}_k + \mathbf{v}_k \Delta t + \frac{1}{2} \left[ \mathbf{R}_k (\tilde{\mathbf{a}}_k - \mathbf{b}_{a,k} - \boldsymbol{\eta}_{a,k}) + \mathbf{g} \right] (\Delta t)^2
                    \]</p>
                </div>
                
                <div class="step">
                    <div class="step-number">4</div>
                    <h3 class="step-title">偏置模型</h3>
                    <p>偏置通常建模为随机游走过程：</p>
                    <p>\[
                    \begin{aligned}
                    \mathbf{b}_{a,k+1} &= \mathbf{b}_{a,k} + \boldsymbol{\eta}_{ba} \Delta t \\
                    \mathbf{b}_{g,k+1} &= \mathbf{b}_{g,k} + \boldsymbol{\eta}_{bg} \Delta t
                    \end{aligned}
                    \]</p>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <div class="card-icon">Δ</div>
                <h2 class="card-title">IMU预积分推导</h2>
            </div>
            
            <p>预积分的核心思想是计算两个关键帧之间的相对运动量，使其独立于初始状态。</p>
            
            <h3 class="section-title">预积分量定义</h3>
            
            <div class="content-container">
                <div class="math-formula">
                    <h3>相对运动量</h3>
                    <p>在时间段 \([t_i, t_j]\) 内：</p>
                    <p>\[
                    \begin{aligned}
                    \boldsymbol{\alpha}_{ij} &= \int_{t_i}^{t_j} \mathbf{v}(t) \, dt \\
                    \boldsymbol{\beta}_{ij} &= \int_{t_i}^{t_j} \mathbf{R}_i^T (\mathbf{a}(t) - \mathbf{g}) \, dt \\
                    \boldsymbol{\gamma}_{ij} &= \prod_{k=i}^{j-1} \exp\left((\tilde{\boldsymbol{\omega}}_k - \mathbf{b}_{g,k}) \Delta t\right)
                    \end{aligned}
                    \]</p>
                    
                    <h3>关键特性</h3>
                    <ul>
                        <li>独立于初始状态 \([\mathbf{p}_i, \mathbf{v}_i, \mathbf{R}_i]\)</li>
                        <li>仅依赖IMU测量和偏置估计</li>
                        <li>可在IMU数据到达时实时计算</li>
                    </ul>
                </div>
                
                <div class="math-formula">
                    <h3>预积分状态传播</h3>
                    <p>预积分量满足以下传播方程：</p>
                    <p>\[
                    \begin{cases}
                    \boldsymbol{\alpha}_{k+1} = \boldsymbol{\alpha}_k + \boldsymbol{\beta}_k \Delta t + \frac{1}{2} \mathbf{R}_k (\tilde{\mathbf{a}}_k - \mathbf{b}_{a,k}) (\Delta t)^2 \\
                    \boldsymbol{\beta}_{k+1} = \boldsymbol{\beta}_k + \mathbf{R}_k (\tilde{\mathbf{a}}_k - \mathbf{b}_{a,k}) \Delta t \\
                    \mathbf{R}_{k+1} = \mathbf{R}_k \exp\left((\tilde{\boldsymbol{\omega}}_k - \mathbf{b}_{g,k}) \Delta t\right)
                    \end{cases}
                    \]</p>
                    
                    <p>其中 \(\boldsymbol{\alpha}, \boldsymbol{\beta}, \mathbf{R}\) 是在初始时刻i的坐标系中定义的。</p>
                </div>
            </div>
            
            <div class="derivation-steps">
                <h3 class="section-title">预积分推导过程</h3>
                
                <div class="step">
                    <div class="step-number">1</div>
                    <h3 class="step-title">定义相对运动</h3>
                    <p>在时间段 \([t_i, t_j]\) 内，位置变化：</p>
                    <p>\[
                    \mathbf{p}_j = \mathbf{p}_i + \mathbf{v}_i \Delta t_{ij} + \iint_{t_i}^{t_j} (\mathbf{R}_t \mathbf{a}_t + \mathbf{g}) \, dt^2
                    \]</p>
                    <p>其中 \(\Delta t_{ij} = t_j - t_i\)。</p>
                </div>
                
                <div class="step">
                    <div class="step-number">2</div>
                    <h3 class="step-title">解耦初始状态</h3>
                    <p>将位置变化分解为：</p>
                    <p>\[
                    \mathbf{p}_j - \mathbf{p}_i - \mathbf{v}_i \Delta t_{ij} - \frac{1}{2} \mathbf{g} \Delta t_{ij}^2 = \iint_{t_i}^{t_j} \mathbf{R}_t \mathbf{a}_t \, dt^2
                    \]</p>
                    <p>右边项仅依赖于相对运动，与初始状态无关。</p>
                </div>
                
                <div class="step">
                    <div class="step-number">3</div>
                    <h3 class="step-title">定义预积分量</h3>
                    <p>令：</p>
                    <p>\[
                    \boldsymbol{\alpha}_{ij} = \iint_{t_i}^{t_j} \mathbf{R}_i^T \mathbf{R}_t \mathbf{a}_t \, dt^2
                    \]</p>
                    <p>\[
                    \boldsymbol{\beta}_{ij} = \int_{t_i}^{t_j} \mathbf{R}_i^T \mathbf{R}_t \mathbf{a}_t \, dt
                    \]</p>
                    <p>\[
                    \boldsymbol{\gamma}_{ij} = \mathbf{R}_i^T \mathbf{R}_j
                    \]</p>
                </div>
                
                <div class="step">
                    <div class="step-number">4</div>
                    <h3 class="step-title">建立递推关系</h3>
                    <p>在时间间隔 \([t_k, t_{k+1}]\) 内：</p>
                    <p>\[
                    \begin{aligned}
                    \boldsymbol{\alpha}_{k+1} &= \boldsymbol{\alpha}_k + \boldsymbol{\beta}_k \Delta t + \frac{1}{2} \boldsymbol{\gamma}_k (\tilde{\mathbf{a}}_k - \mathbf{b}_{a,k}) \Delta t^2 \\
                    \boldsymbol{\beta}_{k+1} &= \boldsymbol{\beta}_k + \boldsymbol{\gamma}_k (\tilde{\mathbf{a}}_k - \mathbf{b}_{a,k}) \Delta t \\
                    \boldsymbol{\gamma}_{k+1} &= \boldsymbol{\gamma}_k \exp\left((\tilde{\boldsymbol{\omega}}_k - \mathbf{b}_{g,k}) \Delta t\right)
                    \end{aligned}
                    \]</p>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <div class="card-icon">σ</div>
                <h2 class="card-title">误差状态与协方差传播</h2>
            </div>
            
            <p>在实际应用中，需要考虑IMU测量的噪声和偏置的不确定性。我们使用误差状态模型来描述这些不确定性。</p>
            
            <h3 class="section-title">误差状态定义</h3>
            
            <div class="content-container">
                <div class="math-formula">
                    <h3>误差状态向量</h3>
                    <p>定义预积分的误差状态向量：</p>
                    <p>\[
                    \delta\mathbf{z}_{ij} = [\delta\boldsymbol{\alpha}_{ij}^T, \delta\boldsymbol{\beta}_{ij}^T, \delta\boldsymbol{\theta}_{ij}^T, \delta\mathbf{b}_{a_i}^T, \delta\mathbf{b}_{g_i}^T]^T
                    \]</p>
                    
                    <h3>误差传播方程</h3>
                    <p>误差状态的连续时间传播方程：</p>
                    <p>\[
                    \begin{align}
                    \delta\dot{\boldsymbol{\alpha}}_{ij} &= \delta\boldsymbol{\beta}_{ij} \\
                    \delta\dot{\boldsymbol{\beta}}_{ij} &= -\mathbf{R}_i^T\mathbf{R}_t[\mathbf{a}_t]_{\times}\delta\boldsymbol{\theta}_{ij} - \mathbf{R}_i^T\mathbf{R}_t\delta\mathbf{b}_{a_i} - \mathbf{R}_i^T\mathbf{R}_t\mathbf{n}_a \\
                    \delta\dot{\boldsymbol{\theta}}_{ij} &= -[\boldsymbol{\omega}_t]_{\times}\delta\boldsymbol{\theta}_{ij} - \delta\mathbf{b}_{g_i} - \mathbf{n}_g \\
                    \delta\dot{\mathbf{b}}_{a_i} &= \mathbf{0} \\
                    \delta\dot{\mathbf{b}}_{g_i} &= \mathbf{0}
                    \end{align}
                    \]</p>
                    
                    <h3>离散化雅可比知阵</h3>
                    <p>离散化后的状态转移矩阵：</p>
                    <p>\[
                    \mathbf{F}_{k+1,k} = \begin{bmatrix}
                    \mathbf{I} & \Delta t \mathbf{I} & \mathbf{0} & \mathbf{f}_{13} & \mathbf{0} \\
                    \mathbf{0} & \mathbf{I} & \mathbf{f}_{23} & \mathbf{f}_{24} & \mathbf{0} \\
                    \mathbf{0} & \mathbf{0} & \mathbf{R}_{k+1,k}^T & \mathbf{0} & \mathbf{f}_{35} \\
                    \mathbf{0} & \mathbf{0} & \mathbf{0} & \mathbf{I} & \mathbf{0} \\
                    \mathbf{0} & \mathbf{0} & \mathbf{0} & \mathbf{0} & \mathbf{I}
                    \end{bmatrix}
                    \]</p>
                    <p>其中：</p>
                    <p>\[
                    \begin{align}
                    \mathbf{f}_{13} &= -\frac{1}{2}\mathbf{R}_i^T\mathbf{R}_k[\mathbf{a}_k - \mathbf{b}_{a_i}]_{\times}\Delta t^2 \\
                    \mathbf{f}_{23} &= -\mathbf{R}_i^T\mathbf{R}_k[\mathbf{a}_k - \mathbf{b}_{a_i}]_{\times}\Delta t \\
                    \mathbf{f}_{24} &= -\mathbf{R}_i^T\mathbf{R}_k\Delta t \\
                    \mathbf{f}_{35} &= -\mathbf{I}\Delta t
                    \end{align}
                    \]</p>
                </div>
                
                <div class="math-formula">
                    <h3>协方差传播</h3>
                    <p>预积分协方差矩阵的递推公式：</p>
                    <p>\[
                    \mathbf{P}_{k+1} = \mathbf{F}_{k+1,k} \mathbf{P}_k \mathbf{F}_{k+1,k}^T + \mathbf{G}_k \mathbf{Q}_k \mathbf{G}_k^T
                    \]</p>
                    <p>其中噪声雅可比矩阵：</p>
                    <p>\[
                    \mathbf{G}_k = \begin{bmatrix}
                    \mathbf{0} & \mathbf{0} & \mathbf{0} & \mathbf{0} \\
                    -\mathbf{R}_i^T\mathbf{R}_k\Delta t & \mathbf{0} & \mathbf{0} & \mathbf{0} \\
                    \mathbf{0} & -\mathbf{I}\Delta t & \mathbf{0} & \mathbf{0} \\
                    \mathbf{0} & \mathbf{0} & \mathbf{I} & \mathbf{0} \\
                    \mathbf{0} & \mathbf{0} & \mathbf{0} & \mathbf{I}
                    \end{bmatrix}
                    \]</p>
                    <p>噪声协方差矩阵：</p>
                    <p>\[
                    \mathbf{Q}_k = \text{diag}(\sigma_a^2\mathbf{I}, \sigma_g^2\mathbf{I}, \sigma_{ba}^2\mathbf{I}, \sigma_{bg}^2\mathbf{I})
                    \]</p>
                </div>
            </div>
            
            <h3 class="section-title">偏置更新的雅可比矩阵</h3>
            
            <div class="math-formula">
                <h3>偏置更新公式</h3>
                <p>当IMU偏置估计更新时，需要重新计算预积分量：</p>
                <p>\[
                \begin{align}
                \hat{\boldsymbol{\alpha}}_{ij} &= \boldsymbol{\alpha}_{ij} + \mathbf{J}_{\alpha}^{ba} \delta\mathbf{b}_{a_i} + \mathbf{J}_{\alpha}^{bg} \delta\mathbf{b}_{g_i} \\
                \hat{\boldsymbol{\beta}}_{ij} &= \boldsymbol{\beta}_{ij} + \mathbf{J}_{\beta}^{ba} \delta\mathbf{b}_{a_i} + \mathbf{J}_{\beta}^{bg} \delta\mathbf{b}_{g_i} \\
                \hat{\boldsymbol{\gamma}}_{ij} &= \boldsymbol{\gamma}_{ij} \text{Exp}(\mathbf{J}_{\gamma}^{bg} \delta\mathbf{b}_{g_i})
                \end{align}
                \]</p>
                <p>其中雅可比矩阵通过数值积分计算得到。</p>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <div class="card-icon">Σ</div>
                <h2 class="card-title">IMU预积分在SLAM中的应用</h2>
            </div>
            
            <div class="key-concept">
                <h3>在R2LIVE/R3LIVE中的应用</h3>
                <p>IMU预积分在R2LIVE和R3LIVE系统中起到关键作用：</p>
                <ul>
                    <li><strong>高频状态传播：</strong>提供200Hz的高频位姿估计</li>
                    <li><strong>紧耦合优化：</strong>与LiDAR和视觉测量联合优化</li>
                    <li><strong>初始化助手：</strong>为视觉-惯性里程计提供初始估计</li>
                    <li><strong>运动模糊处理：</strong>在快速运动时保持系统稳定性</li>
                </ul>
            </div>
            
            <div class="math-formula">
                <h3>优化目标函数</h3>
                <p>在因子图优化中，IMU预积分约束的残差函数：</p>
                <p>\[
                \mathbf{r}_{IMU}(\mathbf{x}_i, \mathbf{x}_j) = \begin{bmatrix}
                \mathbf{R}_i^T(\mathbf{p}_j - \mathbf{p}_i - \mathbf{v}_i\Delta t - \frac{1}{2}\mathbf{g}\Delta t^2) - \hat{\boldsymbol{\alpha}}_{ij} \\
                \mathbf{R}_i^T(\mathbf{v}_j - \mathbf{v}_i - \mathbf{g}\Delta t) - \hat{\boldsymbol{\beta}}_{ij} \\
                \text{Log}(\hat{\boldsymbol{\gamma}}_{ij}^T \mathbf{R}_i^T \mathbf{R}_j)
                \end{bmatrix}
                \]</p>
                <p>残差函数的协方差矩阵为预积分过程中的传播结果。</p>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <div class="card-icon">\[
                    \delta \mathbf{x} = \left[ \delta \boldsymbol{\alpha}^T, \delta \boldsymbol{\beta}^T, \delta \boldsymbol{\theta}^T, \delta \mathbf{b}_a^T, \delta \mathbf{b}_g^T \right]^T
                    \]</p>
                    
                    <p>其中：</p>
                    <ul>
                        <li>\(\delta \boldsymbol{\alpha}, \delta \boldsymbol{\beta}\)：位置和速度误差</li>
                        <li>\(\delta \boldsymbol{\theta}\)：旋转误差（使用李代数表示）</li>
                        <li>\(\delta \mathbf{b}_a, \delta \mathbf{b}_g\)：偏置误差</li>
                    </ul>
                </div>
                
                <div class="math-formula">
                    <h3>误差状态方程</h3>
                    <p>\[
                    \dot{\delta \mathbf{x}} = \mathbf{F} \delta \mathbf{x} + \mathbf{G} \mathbf{n}
                    \]</p>
                    
                    <p>其中：</p>
                    <ul>
                        <li>\(\mathbf{F}\) 是误差状态转移矩阵</li>
                        <li>\(\mathbf{G}\) 是噪声驱动矩阵</li>
                        <li>\(\mathbf{n} = [\boldsymbol{\eta}_a^T, \boldsymbol{\eta}_g^T, \boldsymbol{\eta}_{ba}^T, \boldsymbol{\eta}_{bg}^T]^T\) 是噪声向量</li>
                    </ul>
                </div>
            </div>
            
            <div class="derivation-steps">
                <h3 class="section-title">协方差传播推导</h3>
                
                <div class="step">
                    <div class="step-number">1</div>
                    <h3 class="step-title">误差状态转移矩阵</h3>
                    <p>\[
                    \mathbf{F} = \begin{bmatrix}
                    0 & \mathbf{I} & 0 & 0 & 0 \\
                    0 & 0 & -\mathbf{R} (\tilde{\mathbf{a}} - \mathbf{b}_a)_\times & -\mathbf{R} & 0 \\
                    0 & 0 & -(\tilde{\boldsymbol{\omega}} - \mathbf{b}_g)_\times & 0 & -\mathbf{I} \\
                    0 & 0 & 0 & 0 & 0 \\
                    0 & 0 & 0 & 0 & 0
                    \end{bmatrix}
                    \]</p>
                </div>
                
                <div class="step">
                    <div class="step-number">2</div>
                    <h3 class="step-title">噪声驱动矩阵</h3>
                    <p>\[
                    \mathbf{G} = \begin{bmatrix}
                    0 & 0 & 0 & 0 \\
                    -\mathbf{R} & 0 & 0 & 0 \\
                    0 & -\mathbf{I} & 0 & 0 \\
                    0 & 0 & \mathbf{I} & 0 \\
                    0 & 0 & 0 & \mathbf{I}
                    \end{bmatrix}
                    \]</p>
                </div>
                
                <div class="step">
                    <div class="step-number">3</div>
                    <h3 class="step-title">离散时间协方差传播</h3>
                    <p>使用一阶近似：</p>
                    <p>\[
                    \begin{aligned}
                    \mathbf{F}_d &= \exp(\mathbf{F} \Delta t) \approx \mathbf{I} + \mathbf{F} \Delta t \\
                    \mathbf{G}_d &= \mathbf{G} \Delta t
                    \end{aligned}
                    \]</p>
                    <p>协方差传播：</p>
                    <p>\[
                    \mathbf{P}_{k+1} = \mathbf{F}_d \mathbf{P}_k \mathbf{F}_d^T + \mathbf{G}_d \mathbf{Q} \mathbf{G}_d^T
                    \]</p>
                    <p>其中 \(\mathbf{Q}\) 是噪声协方差矩阵。</p>
                </div>
                
                <div class="step">
                    <div class="step-number">4</div>
                    <h3 class="step-title">偏置更新时的调整</h3>
                    <p>当偏置估计更新时，预积分量需要调整：</p>
                    <p>\[
                    \begin{aligned}
                    \boldsymbol{\alpha} &\leftarrow \boldsymbol{\alpha} + \mathbf{J}_{\boldsymbol{\alpha}, \mathbf{b}_a} \delta \mathbf{b}_a + \mathbf{J}_{\boldsymbol{\alpha}, \mathbf{b}_g} \delta \mathbf{b}_g \\
                    \boldsymbol{\beta} &\leftarrow \boldsymbol{\beta} + \mathbf{J}_{\boldsymbol{\beta}, \mathbf{b}_a} \delta \mathbf{b}_a + \mathbf{J}_{\boldsymbol{\beta}, \mathbf{b}_g} \delta \mathbf{b}_g \\
                    \boldsymbol{\gamma} &\leftarrow \boldsymbol{\gamma} \exp(\mathbf{J}_{\boldsymbol{\gamma}, \mathbf{b}_g} \delta \mathbf{b}_g)
                    \end{aligned}
                    \]</p>
                    <p>其中 \(\mathbf{J}\) 是预积分量对偏置的雅可比矩阵。</p>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>IMU预积分与状态传播详解 | 数学推导与可视化 | 基于SLAM系统实现原理</p>
        </div>
    </div>
    
    <script>
        // State propagation visualization
        const canvas = document.getElementById('stateCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to container
        function resizeCanvas() {
            const container = document.getElementById('state-propagation');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            drawStatePropagation();
        }
        
        // Initial resize
        resizeCanvas();
        
        // Redraw on window resize
        window.addEventListener('resize', resizeCanvas);
        
        // Draw state propagation visualization
        function drawStatePropagation() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw coordinate system
            const originX = width * 0.3;
            const originY = height * 0.7;
            const scale = 0.8;
            
            // Draw world coordinate frame
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            drawArrow(ctx, originX, originY, originX + 100 * scale, originY, 10);
            drawArrow(ctx, originX, originY, originX, originY - 80 * scale, 10);
            ctx.fillStyle = '#3498db';
            ctx.font = '16px Arial';
            ctx.fillText('X_w', originX + 110 * scale, originY - 5);
            ctx.fillText('Z_w', originX - 10, originY - 90 * scale);
            
            // Draw body trajectory
            ctx.beginPath();
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.moveTo(originX, originY);
            
            // Simulate a trajectory
            for (let i = 1; i <= 5; i++) {
                const x = originX + i * 40 * scale;
                const y = originY - i * 20 * scale;
                ctx.lineTo(x, y);
                
                // Draw body frame at each point
                drawBodyFrame(ctx, x, y, i * 0.3, 25 * scale);
                
                // Draw IMU measurements
                if (i < 5) {
                    const midX = (x + (x + 40 * scale)) / 2;
                    const midY = (y + (y - 20 * scale)) / 2;
                    
                    // Angular velocity
                    ctx.fillStyle = '#9b59b6';
                    ctx.beginPath();
                    ctx.arc(midX, midY - 15, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText('ω', midX - 4, midY - 11);
                    
                    // Acceleration
                    ctx.fillStyle = '#2ecc71';
                    ctx.beginPath();
                    ctx.arc(midX, midY + 15, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText('a', midX - 3, midY + 18);
                }
            }
            
            ctx.stroke();
            
            // Draw legend
            ctx.fillStyle = '#2c3e50';
            ctx.font = '14px Arial';
            ctx.fillText('世界坐标系', originX - 30, originY + 30);
            ctx.fillText('机体轨迹', originX + 150 * scale, originY - 80 * scale);
            
            // Draw IMU sensor
            const imuX = originX + 250 * scale;
            const imuY = originY - 120 * scale;
            ctx.fillStyle = '#34495e';
            ctx.fillRect(imuX, imuY, 80 * scale, 50 * scale);
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.fillText('IMU', imuX + 25 * scale, imuY + 30 * scale);
            
            // Draw connection lines
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(imuX, imuY);
            for (let i = 1; i <= 5; i++) {
                const x = originX + i * 40 * scale;
                const y = originY - i * 20 * scale;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Draw a body coordinate frame
        function drawBodyFrame(ctx, x, y, angle, size) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            // Draw frame
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 2;
            drawArrow(ctx, 0, 0, size, 0, 8);
            drawArrow(ctx, 0, 0, 0, -size, 8);
            
            // Draw body
            ctx.fillStyle = 'rgba(231, 76, 60, 0.7)';
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Draw an arrow
        function drawArrow(ctx, fromX, fromY, toX, toY, headLength) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // Draw arrowhead
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
        }
        
        // Tab switching
        document.querySelectorAll('.nav-btn').forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons
                document.querySelectorAll('.nav-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Add active class to clicked button
                button.classList.add('active');
            });
        });
    </script>
</body>
</html>