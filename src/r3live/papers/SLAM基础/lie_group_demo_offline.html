<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>李群李代数 SE(3) 离线仿真</title>
<style>
    body { margin: 0; font-family: Arial; background: #f0f0f0; }
    #container { width: 70%; height: 100vh; float: left; background: #eaeaea; }
    #info { width: 30%; height: 100vh; float: left; background: white; overflow-y: auto; padding: 15px; }
    h2 { margin-top: 0; }
    .slider-container { margin: 5px 0; }
    .slider-container label { display: inline-block; width: 90px; }
</style>
</head>
<body>
<div id="container"></div>
<div id="info">
    <h2>李群李代数 SE(3) 演示</h2>
    <p>调整下面的滑块，改变李代数向量：</p>
    <div id="sliders"></div>
    <hr>
    <h3>公式</h3>
    <p>SE(3) 位姿矩阵：</p>
    <div>\(T = \begin{bmatrix} R & t \\ 0 & 1 \end{bmatrix}\)</div>
    <p>李代数：</p>
    <div>\(\xi = \begin{bmatrix} v \\ \omega \end{bmatrix}\)</div>
    <p>指数映射：</p>
    <div>
        \(\mathrm{Exp}(\xi) = 
        \begin{bmatrix}
        \mathrm{Exp}(\omega^\wedge) & J(\omega)v \\
        0 & 1
        \end{bmatrix}\)
    </div>
</div>

<!-- three.js 离线版 -->
<script>
/* three.min.js 离线源码粘贴在这里（很长，省略） */
</script>

<!-- OrbitControls 离线版 -->
<script>
/* OrbitControls.js 离线源码粘贴在这里（很长，省略） */
</script>

<script>
// === 生成滑块 ===
const sliderLabels = ["v_x", "v_y", "v_z", "ω_x", "ω_y", "ω_z"];
let xi = [0, 0, 0, 0, 0, 0];
const slidersDiv = document.getElementById("sliders");

sliderLabels.forEach((label, i) => {
    const div = document.createElement("div");
    div.className = "slider-container";
    div.innerHTML = `<label>${label}:</label>
        <input type="range" min="-1" max="1" step="0.01" value="0" id="slider${i}">
        <span id="value${i}">0</span>`;
    slidersDiv.appendChild(div);

    const slider = div.querySelector("input");
    const valueSpan = div.querySelector("span");
    slider.addEventListener("input", () => {
        xi[i] = parseFloat(slider.value);
        valueSpan.textContent = slider.value;
        updatePose();
    });
});

// === three.js 场景 ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth*0.7/window.innerHeight, 0.1, 1000);
camera.position.set(4, 3, 6);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth*0.7, window.innerHeight);
document.getElementById("container").appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
scene.add(new THREE.AxesHelper(2));

// 光照
scene.add(new THREE.AmbientLight(0x555555));
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 10, 7);
scene.add(light);

// 机器人
const robotGeom = new THREE.BoxGeometry(1, 0.5, 0.5);
const robotMat = new THREE.MeshPhongMaterial({color: 0x0077ff});
const robot = new THREE.Mesh(robotGeom, robotMat);
scene.add(robot);

// === 李代数指数映射函数 ===
function hat(omega) {
    return new THREE.Matrix3().set(
        0, -omega[2], omega[1],
        omega[2], 0, -omega[0],
        -omega[1], omega[0], 0
    );
}

function expSO3(omega) {
    const theta = Math.hypot(...omega);
    const I = new THREE.Matrix3().identity();
    if (theta < 1e-8) return I;

    const omegaHat = hat(omega);
    const omegaHat2 = omegaHat.clone().multiply(omegaHat);
    const s = Math.sin(theta), c = Math.cos(theta);

    const term1 = omegaHat.clone().multiplyScalar(s/theta);
    const term2 = omegaHat2.clone().multiplyScalar((1-c)/(theta*theta));

    return I.clone().add(term1).add(term2);
}

function leftJacobianSO3(omega) {
    const theta = Math.hypot(...omega);
    const I = new THREE.Matrix3().identity();
    if (theta < 1e-8) return I;

    const omegaHat = hat(omega);
    const omegaHat2 = omegaHat.clone().multiply(omegaHat);
    const s = Math.sin(theta), c = Math.cos(theta);

    const term1 = omegaHat.clone().multiplyScalar((1-c)/(theta*theta));
    const term2 = omegaHat2.clone().multiplyScalar((theta-s)/(theta*theta*theta));

    return I.clone().add(term1).add(term2);
}

function expSE3(xi) {
    const v = xi.slice(0,3);
    const omega = xi.slice(3,6);

    const Rm = expSO3(omega);
    const J = leftJacobianSO3(omega);

    const tVec = new THREE.Vector3(...v);
    const J3 = new THREE.Matrix3().copy(J);
    const tOut = tVec.applyMatrix3(J3);

    const T = new THREE.Matrix4();
    T.set(
        Rm.elements[0], Rm.elements[3], Rm.elements[6], tOut.x,
        Rm.elements[1], Rm.elements[4], Rm.elements[7], tOut.y,
        Rm.elements[2], Rm.elements[5], Rm.elements[8], tOut.z,
        0, 0, 0, 1
    );
    return T;
}

// 更新位姿
function updatePose() {
    const T = expSE3(xi);
    robot.matrix.copy(T);
    robot.matrixAutoUpdate = false;
}

updatePose();

// 渲染循环
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth*0.7 / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth*0.7, window.innerHeight);
});
</script>
</body>
</html>
