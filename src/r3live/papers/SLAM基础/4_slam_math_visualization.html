<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLAM数学原理可视化 - R2LIVE & R3LIVE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            padding: 40px 0;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .section {
            background: rgba(255, 255, 255, 0.95);
            margin: 30px 0;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 2em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .math-formula {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
            border-left: 5px solid #667eea;
            font-size: 1.1em;
            overflow-x: auto;
            color: #2d3748;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .math-formula h4 {
            color: #4a5568;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        .math-formula p {
            margin: 10px 0;
            line-height: 1.6;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .comparison-table th,
        .comparison-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        .sensor-fusion-demo {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .sensor-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .sensor-card:hover {
            transform: scale(1.05);
        }

        .sensor-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .algorithm-flow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 30px 0;
            flex-wrap: wrap;
            gap: 20px;
        }

        .flow-step {
            background: #667eea;
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            flex: 1;
            min-width: 200px;
            position: relative;
        }

        .flow-step:not(:last-child)::after {
            content: '→';
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 2em;
            color: #667eea;
        }

        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #667eea;
        }

        .interactive-demo {
            background: #2d3748;
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
        }

        .demo-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group input {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            background: #4a5568;
            color: white;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .visualization-canvas {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            background: #1a202c;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 SLAM数学原理可视化</h1>
            <p>R2LIVE & R3LIVE 核心算法深度解析</p>
        </div>

        <!-- 系统概述 -->
        <div class="section">
            <h2>📊 系统架构对比</h2>
            <div class="sensor-fusion-demo">
                <div class="sensor-card">
                    <div class="sensor-icon">📷</div>
                    <h3>视觉传感器</h3>
                    <p>提供丰富的环境纹理信息，但在光照变化和纹理缺失时性能下降</p>
                </div>
                <div class="sensor-card">
                    <div class="sensor-icon">🎯</div>
                    <h3>LiDAR传感器</h3>
                    <p>提供精确的距离测量，不受光照影响，但信息密度相对较低</p>
                </div>
                <div class="sensor-card">
                    <div class="sensor-icon">🧭</div>
                    <h3>惯性传感器</h3>
                    <p>提供高频运动信息，但存在漂移问题，需要其他传感器校正</p>
                </div>
            </div>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>特性</th>
                        <th>R2LIVE</th>
                        <th>R3LIVE</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>视觉处理方式</strong></td>
                        <td>基于特征点匹配</td>
                        <td>直接光度误差最小化</td>
                    </tr>
                    <tr>
                        <td><strong>地图表示</strong></td>
                        <td>几何结构地图</td>
                        <td>几何+RGB纹理地图</td>
                    </tr>
                    <tr>
                        <td><strong>核心算法</strong></td>
                        <td>误差状态卡尔曼滤波器</td>
                        <td>LIO + VIO双子系统</td>
                    </tr>
                    <tr>
                        <td><strong>优化策略</strong></td>
                        <td>滑动窗口因子图优化</td>
                        <td>帧到地图直接匹配</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- R2LIVE数学原理 -->
        <div class="section">
            <h2>🔬 R2LIVE数学原理</h2>
            
            <h3>1. 状态向量定义</h3>
            <div class="math-formula">
                $$\mathbf{x} = \begin{bmatrix} \mathbf{p} \\ \mathbf{v} \\ \mathbf{q} \\ \mathbf{b}_a \\ \mathbf{b}_g \\ \mathbf{\lambda} \end{bmatrix}$$
                
                其中：
                <ul style="margin-top: 10px;">
                    <li><strong>p</strong>: 位置向量 (3×1)</li>
                    <li><strong>v</strong>: 速度向量 (3×1)</li>
                    <li><strong>q</strong>: 四元数姿态 (4×1)</li>
                    <li><strong>b<sub>a</sub></strong>: 加速度计偏置 (3×1)</li>
                    <li><strong>b<sub>g</sub></strong>: 陀螺仪偏置 (3×1)</li>
                    <li><strong>λ</strong>: 视觉特征逆深度 (N×1)</li>
                </ul>
            </div>

            <h3>2. 误差状态卡尔曼滤波器</h3>
            <div class="math-formula">
                <strong>预测步骤：</strong>
                $$\hat{\mathbf{x}}_{k|k-1} = f(\hat{\mathbf{x}}_{k-1|k-1}, \mathbf{u}_k)$$
                $$\mathbf{P}_{k|k-1} = \mathbf{F}_k \mathbf{P}_{k-1|k-1} \mathbf{F}_k^T + \mathbf{Q}_k$$
                
                <strong>更新步骤：</strong>
                $$\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}_k^T (\mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^T + \mathbf{R}_k)^{-1}$$
                $$\hat{\mathbf{x}}_{k|k} = \hat{\mathbf{x}}_{k|k-1} + \mathbf{K}_k (\mathbf{z}_k - h(\hat{\mathbf{x}}_{k|k-1}))$$
                $$\mathbf{P}_{k|k} = (\mathbf{I} - \mathbf{K}_k \mathbf{H}_k) \mathbf{P}_{k|k-1}$$
            </div>

            <div class="algorithm-flow">
                <div class="flow-step">
                    <h4>IMU数据</h4>
                    <p>加速度计<br>陀螺仪</p>
                </div>
                <div class="flow-step">
                    <h4>预积分</h4>
                    <p>运动模型<br>预测</p>
                </div>
                <div class="flow-step">
                    <h4>特征匹配</h4>
                    <p>LiDAR点<br>视觉特征</p>
                </div>
                <div class="flow-step">
                    <h4>状态更新</h4>
                    <p>卡尔曼滤波<br>优化</p>
                </div>
            </div>
        </div>

        <!-- R3LIVE数学原理 -->
        <div class="section">
            <h2>🎨 R3LIVE数学原理</h2>
            
            <h3>1. 直接光度误差</h3>
            <div class="math-formula">
                $$E_{photo} = \sum_{i} \sum_{\mathbf{p} \in \Omega_i} \| I_i(\mathbf{p}) - I_{ref}(\pi(\mathbf{T} \mathbf{P}(\mathbf{p}))) \|^2$$
                
                其中：
                <ul style="margin-top: 10px;">
                    <li><strong>I<sub>i</sub>(p)</strong>: 当前帧在像素p处的强度</li>
                    <li><strong>I<sub>ref</sub></strong>: 参考图像强度</li>
                    <li><strong>π(·)</strong>: 相机投影函数</li>
                    <li><strong>T</strong>: 相机位姿变换</li>
                    <li><strong>P(p)</strong>: 像素p对应的3D点</li>
                </ul>
            </div>

            <h3>2. LIO-VIO双子系统</h3>
            <div class="highlight">
                <h4>🔧 LIO子系统 (FAST-LIO)</h4>
                <p><strong>功能</strong>: 构建环境的几何结构，提供精确的3D点云地图</p>
                <p><strong>输入</strong>: LiDAR点云 + IMU数据</p>
                <p><strong>输出</strong>: 机器人位姿 + 3D几何地图</p>
            </div>

            <div class="highlight">
                <h4>🎨 VIO子系统</h4>
                <p><strong>功能</strong>: 为3D点云添加RGB颜色信息，渲染地图纹理</p>
                <p><strong>输入</strong>: 相机图像 + IMU数据 + LIO位姿</p>
                <p><strong>输出</strong>: RGB彩色点云地图</p>
            </div>
        </div>

        <!-- 交互式演示 -->
        <div class="section">
            <h2>🎮 交互式卡尔曼滤波演示</h2>
            
            <div class="interactive-demo">
                <h3>多传感器融合可视化</h3>
                <div class="demo-controls">
                    <div class="control-group">
                        <label>过程噪声 Q:</label>
                        <input type="range" id="processNoise" min="0.1" max="2" step="0.1" value="0.5">
                        <span id="qValue">0.5</span>
                    </div>
                    <div class="control-group">
                        <label>观测噪声 R:</label>
                        <input type="range" id="observationNoise" min="0.1" max="2" step="0.1" value="0.3">
                        <span id="rValue">0.3</span>
                    </div>
                    <button class="btn" onclick="startSimulation()">开始仿真</button>
                    <button class="btn" onclick="resetSimulation()">重置</button>
                </div>
                <canvas id="kalmanCanvas" class="visualization-canvas"></canvas>
            </div>
        </div>

        <!-- IMU预积分仿真 -->
        <div class="section">
            <h2>🎯 IMU预积分数学仿真</h2>
            
            <h3>IMU预积分数学模型</h3>
            <div class="math-formula">
                <strong>IMU预积分公式：</strong>
                $$\Delta \mathbf{p}_{ij} = \int_{t_i}^{t_j} \left[ \int_{t_i}^{s} (\mathbf{R}_t (\tilde{\mathbf{a}}_t - \mathbf{b}_{a_t} - \mathbf{n}_a) - \mathbf{g}) d\tau \right] ds$$
                $$\Delta \mathbf{v}_{ij} = \int_{t_i}^{t_j} (\mathbf{R}_t (\tilde{\mathbf{a}}_t - \mathbf{b}_{a_t} - \mathbf{n}_a) - \mathbf{g}) dt$$
                $$\Delta \mathbf{R}_{ij} = \prod_{k=i}^{j-1} \text{Exp}((\tilde{\mathbf{\omega}}_k - \mathbf{b}_{g_k} - \mathbf{n}_g) \Delta t)$$
                
                <strong>噪声模型：</strong>
                $$\mathbf{n}_a \sim \mathcal{N}(\mathbf{0}, \sigma_a^2 \mathbf{I}), \quad \mathbf{n}_g \sim \mathcal{N}(\mathbf{0}, \sigma_g^2 \mathbf{I})$$
                
                <strong>偏置随机游走：</strong>
                $$\dot{\mathbf{b}}_a = \mathbf{n}_{ba}, \quad \dot{\mathbf{b}}_g = \mathbf{n}_{bg}$$
                
                其中：
                <ul style="margin-top: 10px;">
                    <li><strong>Δp<sub>ij</sub></strong>: 预积分位移</li>
                    <li><strong>Δv<sub>ij</sub></strong>: 预积分速度</li>
                    <li><strong>ΔR<sub>ij</sub></strong>: 预积分旋转</li>
                    <li><strong>σ<sub>a</sub></strong>: 加速度计噪声标准差</li>
                    <li><strong>σ<sub>g</sub></strong>: 陀螺仪噪声标准差</li>
                    <li><strong>b<sub>a</sub>, b<sub>g</sub></strong>: IMU偏置</li>
                    <li><strong>ds</strong>: 外层积分的时间微元，表示位置积分的时间步长</li>
                    <li><strong>dτ</strong>: 内层积分的时间微元，表示速度积分的时间步长</li>
                    <li><strong>dt</strong>: 单层积分的时间微元，表示速度和旋转积分的时间步长</li>
                </ul>
            </div>
            
            <div class="interactive-demo">
                <h3>IMU数据预积分可视化</h3>
                <div class="demo-controls">
                    <div class="control-group">
                        <label>加速度计噪声 \(\sigma_a\):</label>
                        <input type="range" id="accNoise" min="0.01" max="0.5" step="0.01" value="0.1">
                        <span id="accNoiseValue">0.1</span> m/s²
                    </div>
                    <div class="control-group">
                        <label>陀螺仪噪声 \(\sigma_g\):</label>
                        <input type="range" id="gyroNoise" min="0.01" max="0.3" step="0.01" value="0.05">
                        <span id="gyroNoiseValue">0.05</span> rad/s
                    </div>
                    <div class="control-group">
                        <label>IMU频率 \(f_{IMU}\):</label>
                        <input type="range" id="imuFreq" min="50" max="500" step="50" value="200">
                        <span id="imuFreqValue">200</span> Hz
                    </div>
                    <div class="control-group">
                        <label>加速度计偏置 \(\mathbf{b}_a\):</label>
                        <input type="range" id="accBias" min="-0.5" max="0.5" step="0.01" value="0.1">
                        <span id="accBiasValue">0.1</span> m/s²
                    </div>
                    <div class="control-group">
                        <label>陀螺仪偏置 \(\mathbf{b}_g\):</label>
                        <input type="range" id="gyroBias" min="-0.1" max="0.1" step="0.001" value="0.02">
                        <span id="gyroBiasValue">0.02</span> rad/s
                    </div>
                    <div class="control-group">
                        <label>预积分时间间隔 \(\Delta t\):</label>
                        <input type="range" id="preintTime" min="0.1" max="2.0" step="0.1" value="0.5">
                        <span id="preintTimeValue">0.5</span> s
                    </div>
                    <button class="btn" onclick="startIMUSimulation()">开始IMU仿真</button>
                    <button class="btn" onclick="resetIMUSimulation()">重置</button>
                </div>
                
                <!-- 参数调整指南 -->
                <div class="math-formula" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">🎯 仿真参数调整指南</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 13px; color: #e0e0e0;">
                        <div>
                            <h5 style="color: #ff6b6b; margin-bottom: 10px;">噪声参数影响：</h5>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #ff8a8a;">加大 σₐ</strong>：加速度计噪声增大 → 位移轨迹更加抖动，预积分精度下降</li>
                                <li><strong style="color: #ff8a8a;">减小 σₐ</strong>：加速度计噪声减小 → 位移轨迹更加平滑，预积分精度提升</li>
                                <li><strong style="color: #ff8a8a;">加大 σₘ</strong>：陀螺仪噪声增大 → 姿态变化更加抖动，旋转预积分精度下降</li>
                                <li><strong style="color: #ff8a8a;">减小 σₘ</strong>：陀螺仪噪声减小 → 姿态变化更加平滑，旋转预积分精度提升</li>
                            </ul>
                        </div>
                        <div>
                            <h5 style="color: #ffaa00; margin-bottom: 10px;">偏置参数影响：</h5>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #ffcc66;">加大 |bₐ|</strong>：加速度计偏置增大 → 位移轨迹系统性偏移，累积误差增大</li>
                                <li><strong style="color: #ffcc66;">减小 |bₐ|</strong>：加速度计偏置减小 → 位移轨迹更加准确，累积误差减小</li>
                                <li><strong style="color: #ffcc66;">加大 |bₘ|</strong>：陀螺仪偏置增大 → 姿态角度系统性偏移，旋转误差累积</li>
                                <li><strong style="color: #ffcc66;">减小 |bₘ|</strong>：陀螺仪偏置减小 → 姿态角度更加准确，旋转误差减小</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <h5 style="color: #4ecdc4; margin-bottom: 10px;">系统参数影响：</h5>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 13px; color: #e0e0e0;">
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #66d9d9;">提高 f_{IMU}</strong>：IMU采样频率增大 → 数据更加密集，预积分精度提升，但计算量增大</li>
                                <li><strong style="color: #66d9d9;">降低 f_{IMU}</strong>：IMU采样频率减小 → 数据稀疏，预积分精度下降，但计算量减小</li>
                            </ul>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #66d9d9;">增大 Δt</strong>：预积分时间间隔增大 → 预积分数据更新频率降低，误差累积增大</li>
                                <li><strong style="color: #66d9d9;">减小 Δt</strong>：预积分时间间隔减小 → 预积分数据更新频率提高，误差累积减小</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: rgba(78, 205, 196, 0.1); border-left: 3px solid #4ecdc4; border-radius: 4px;">
                        <strong style="color: #4ecdc4;">💡 实验建议：</strong>
                        <span style="font-size: 12px;">先调整噪声参数观察随机性影响，再调整偏置参数观察系统性误差，最后调整系统参数优化性能。</span>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-top: 20px;">
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">位置轨迹可视化</h4>
                        <canvas id="imuPositionCanvas" class="visualization-canvas" style="height: 280px;"></canvas>
                    </div>
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">姿态变化可视化</h4>
                        <canvas id="imuOrientationCanvas" class="visualization-canvas" style="height: 280px;"></canvas>
                    </div>
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">变量影响分析</h4>
                        <canvas id="imuVariableCanvas" class="visualization-canvas" style="height: 280px;"></canvas>
                    </div>
                </div>
                <div class="math-formula" style="margin-top: 20px;">
                    <h4>可视化与数学模型对应关系</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <strong>可视化变量：</strong>
                            <ul style="margin-top: 10px; font-size: 14px;">
                                <li><strong>Δpᵢⱼ</strong>: 预积分位移</li>
                                <li><strong>Δvᵢⱼ</strong>: 预积分速度</li>
                                <li><strong>ΔRᵢⱼ</strong>: 预积分旋转</li>
                                <li><strong>bₐ, bₘ</strong>: IMU偏置</li>
                                <li><strong>σₐ, σₘ</strong>: 噪声标准差</li>
                            </ul>
                        </div>
                        <div>
                            <strong>数学模型公式：</strong>
                            <ul style="margin-top: 10px; font-size: 14px;">
                                <li>$$\Delta \mathbf{p}_{ij} = \int_{t_i}^{t_j} \left[ \int_{t_i}^{s} (\mathbf{R}_t (\tilde{\mathbf{a}}_t - \mathbf{b}_{a_t} - \mathbf{n}_a) - \mathbf{g}) d\tau \right] ds$$</li>
                                <li>$$\Delta \mathbf{v}_{ij} = \int_{t_i}^{t_j} (\mathbf{R}_t (\tilde{\mathbf{a}}_t - \mathbf{b}_{a_t} - \mathbf{n}_a) - \mathbf{g}) dt$$</li>
                                <li>$$\Delta \mathbf{R}_{ij} = \prod_{k=i}^{j-1} \text{Exp}((\tilde{\mathbf{\omega}}_k - \mathbf{b}_{g_k} - \mathbf{n}_g) \Delta t)$$</li>
                                <li>$$\mathbf{n}_a \sim \mathcal{N}(\mathbf{0}, \sigma_a^2 \mathbf{I}), \quad \mathbf{n}_g \sim \mathcal{N}(\mathbf{0}, \sigma_g^2 \mathbf{I})$$</li>
                                <li>$$\dot{\mathbf{b}}_a = \mathbf{n}_{ba}, \quad \dot{\mathbf{b}}_g = \mathbf{n}_{bg}$$</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 因子图优化仿真 -->
        <div class="section">
            <h2>🔗 因子图优化仿真</h2>
            
            <!-- 因子图优化数学模型 -->
            <div class="math-formula">
                <h3>因子图优化数学模型</h3>
                <p><strong>目标函数：</strong></p>
                $$\mathbf{X}^* = \arg\min_{\mathbf{X}} \sum_{i} \left\| \mathbf{e}_i(\mathbf{X}_i) \right\|_{\mathbf{\Sigma}_i}^2$$
                
                <p><strong>高斯-牛顿迭代：</strong></p>
                $$\mathbf{H} \mathbf{\delta} = -\mathbf{g}$$
                
                <p><strong>海塞矩阵和梯度：</strong></p>
                $$\mathbf{H} = \sum_i \mathbf{J}_i^T \mathbf{\Sigma}_i^{-1} \mathbf{J}_i, \quad \mathbf{g} = \sum_i \mathbf{J}_i^T \mathbf{\Sigma}_i^{-1} \mathbf{e}_i$$
                
                <p><strong>误差函数：</strong></p>
                $$\mathbf{e}_i(\mathbf{X}_i) = \mathbf{z}_i - \mathbf{h}_i(\mathbf{X}_i)$$
                
                <p><strong>雅可比矩阵：</strong></p>
                $$\mathbf{J}_i = \frac{\partial \mathbf{e}_i}{\partial \mathbf{X}_i}$$
                
                其中：
                <ul style="margin-top: 10px;">
                    <li><strong>N</strong>: 因子图节点数量</li>
                    <li><strong>σ<sub>obs</sub></strong>: 观测噪声标准差</li>
                    <li><strong>k<sub>max</sub></strong>: 最大迭代次数</li>
                    <li><strong>λ<sub>damp</sub></strong>: 阻尼因子（Levenberg-Marquardt参数）</li>
                    <li><strong>ε<sub>conv</sub></strong>: 收敛阈值</li>
                    <li><strong>α<sub>step</sub></strong>: 步长因子</li>
                </ul>
            </div>
            
            <div class="interactive-demo">
                <h3>多传感器因子图优化可视化</h3>
                <div class="demo-controls">
                    <div class="control-group">
                        <label>节点数量 \(N\):</label>
                        <input type="range" id="nodeCount" min="5" max="20" step="1" value="10">
                        <span id="nodeCountValue">10</span> 个
                    </div>
                    <div class="control-group">
                        <label>观测噪声 \(\sigma_{obs}\):</label>
                        <input type="range" id="obsNoise" min="0.1" max="2.0" step="0.1" value="0.5">
                        <span id="obsNoiseValue">0.5</span> m
                    </div>
                    <div class="control-group">
                        <label>最大迭代次数 \(k_{max}\):</label>
                        <input type="range" id="optIterations" min="1" max="50" step="1" value="20">
                        <span id="optIterValue">20</span> 次
                    </div>
                    <div class="control-group">
                        <label>阻尼因子 \(\lambda_{damp}\):</label>
                        <input type="range" id="dampingFactor" min="0.001" max="1.0" step="0.001" value="0.1">
                        <span id="dampingFactorValue">0.1</span>
                    </div>
                    <div class="control-group">
                        <label>收敛阈值 \(\varepsilon_{conv}\):</label>
                        <input type="range" id="convergenceThreshold" min="0.001" max="0.1" step="0.001" value="0.01">
                        <span id="convergenceThresholdValue">0.01</span>
                    </div>
                    <div class="control-group">
                        <label>步长因子 \(\alpha_{step}\):</label>
                        <input type="range" id="stepFactor" min="0.1" max="2.0" step="0.1" value="1.0">
                        <span id="stepFactorValue">1.0</span>
                    </div>
                    <button class="btn" onclick="startFactorGraphSimulation()">开始因子图优化</button>
                    <button class="btn" onclick="resetFactorGraphSimulation()">重置</button>
                </div>
                
                <!-- 参数调整指南 -->
                <div class="math-formula" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">🎯 仿真参数调整指南</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 13px; color: #e0e0e0;">
                        <div>
                            <h5 style="color: #ff6b6b; margin-bottom: 10px;">系统参数影响：</h5>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #ff8a8a;">增加 N</strong>：节点数量增大 → 因子图复杂度提高，优化精度提升，但计算时间增加</li>
                                <li><strong style="color: #ff8a8a;">减少 N</strong>：节点数量减少 → 因子图简化，优化速度提高，但精度下降</li>
                                <li><strong style="color: #ff8a8a;">增大 k<sub>max</sub></strong>：最大迭代次数增加 → 优化更充分，收敛精度提高，但计算时间增加</li>
                                <li><strong style="color: #ff8a8a;">减少 k<sub>max</sub></strong>：最大迭代次数减少 → 优化速度提高，但可能未充分收敛</li>
                            </ul>
                        </div>
                        <div>
                            <h5 style="color: #ffaa00; margin-bottom: 10px;">噪声参数影响：</h5>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #ffcc66;">增大 σ<sub>obs</sub></strong>：观测噪声增大 → 估计不确定性增加，优化结果更加平滑但精度下降</li>
                                <li><strong style="color: #ffcc66;">减小 σ<sub>obs</sub></strong>：观测噪声减小 → 估计更加精确，优化结果更接近观测值</li>
                                <li><strong style="color: #ffcc66;">增大 λ<sub>damp</sub></strong>：阻尼因子增大 → 优化更加稳定，但收敛速度变慢</li>
                                <li><strong style="color: #ffcc66;">减小 λ<sub>damp</sub></strong>：阻尼因子减小 → 收敛速度加快，但可能产生振荡</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <h5 style="color: #4ecdc4; margin-bottom: 10px;">优化参数影响：</h5>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 13px; color: #e0e0e0;">
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #66d9d9;">提高 ε<sub>conv</sub></strong>：收敛阈值提高 → 优化提前终止，速度提高但精度下降</li>
                                <li><strong style="color: #66d9d9;">降低 ε<sub>conv</sub></strong>：收敛阈值降低 → 优化更加精细，精度提高但时间增加</li>
                            </ul>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #66d9d9;">增大 α<sub>step</sub></strong>：步长因子增大 → 收敛速度加快，但可能超调或发散</li>
                                <li><strong style="color: #66d9d9;">减小 α<sub>step</sub></strong>：步长因子减小 → 优化更加稳定，但收敛速度变慢</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: rgba(78, 205, 196, 0.1); border-left: 3px solid #4ecdc4; border-radius: 4px;">
                        <strong style="color: #4ecdc4;">💡 实验建议：</strong>
                        <span style="font-size: 12px;">先调整系统参数观察因子图结构，再调整噪声参数观察稳定性，最后调整优化参数提高收敛效率。</span>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-top: 20px;">
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">因子图结构可视化</h4>
                        <canvas id="factorGraphCanvas" class="visualization-canvas" style="height: 280px;"></canvas>
                    </div>
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">优化收敛曲线</h4>
                        <canvas id="convergenceCanvas" class="visualization-canvas" style="height: 280px;"></canvas>
                    </div>
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">参数影响分析</h4>
                        <canvas id="factorGraphVariableCanvas" class="visualization-canvas" style="height: 280px;"></canvas>
                    </div>
                </div>
                
                <!-- 可视化与数学模型对应关系 -->
                <div class="math-formula" style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">🔗 可视化与数学模型对应关系</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 14px; color: #e0e0e0;">
                        <div>
                            <strong>仿真参数与数学变量对应：</strong>
                            <ul style="margin-top: 10px; font-size: 13px; color: #e0e0e0;">
                                <li><strong style="color: #ff8a8a;">N</strong> ↔ 因子图节点数量</li>
                                <li><strong style="color: #ff8a8a;">σ<sub>obs</sub></strong> ↔ 观测噪声协方差矩阵 Σ<sub>i</sub></li>
                                <li><strong style="color: #ff8a8a;">k<sub>max</sub></strong> ↔ 高斯-牛顿迭代次数</li>
                                <li><strong style="color: #ffcc66;">λ<sub>damp</sub></strong> ↔ Levenberg-Marquardt阻尼参数</li>
                                <li><strong style="color: #ffcc66;">ε<sub>conv</sub></strong> ↔ 收敛判断阈值</li>
                                <li><strong style="color: #66d9d9;">α<sub>step</sub></strong> ↔ 优化步长系数</li>
                            </ul>
                        </div>
                        <div>
                            <strong>数学模型公式：</strong>
                            <ul style="margin-top: 10px; font-size: 14px;">
                                <li>$$\mathbf{X}^* = \arg\min_{\mathbf{X}} \sum_{i} \left\| \mathbf{e}_i(\mathbf{X}_i) \right\|_{\mathbf{\Sigma}_i}^2$$</li>
                                <li>$$\mathbf{H} \mathbf{\delta} = -\mathbf{g}$$</li>
                                <li>$$\mathbf{H} = \sum_i \mathbf{J}_i^T \mathbf{\Sigma}_i^{-1} \mathbf{J}_i + \lambda_{damp} \mathbf{I}$$</li>
                                <li>$$\mathbf{e}_i(\mathbf{X}_i) = \mathbf{z}_i - \mathbf{h}_i(\mathbf{X}_i)$$</li>
                                <li>$$\|\mathbf{g}\| < \varepsilon_{conv} \text{ (收敛条件)}$$</li>
                                <li>$$\mathbf{X}_{k+1} = \mathbf{X}_k + \alpha_{step} \mathbf{\delta}$$</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ESIKF仿真 -->
        <div class="section">
            <h2>🎛️ 误差状态迭代卡尔曼滤波仿真</h2>
            
            <div class="interactive-demo">
                <h3>ESIKF多传感器融合可视化</h3>
                <div class="demo-controls">
                    <div class="control-group">
                        <label>IMU频率 \(f_{\text{IMU}}\):</label>
                        <input type="range" id="esikfIMUFreq" min="100" max="1000" step="100" value="400">
                        <span id="esikfIMUFreqValue">400</span> Hz
                    </div>
                    <div class="control-group">
                        <label>相机频率 \(f_{\text{cam}}\):</label>
                        <input type="range" id="esikfCamFreq" min="10" max="60" step="10" value="30">
                        <span id="esikfCamFreqValue">30</span> Hz
                    </div>
                    <div class="control-group">
                        <label>过程噪声 \(\sigma_Q\):</label>
                        <input type="range" id="esikfProcessNoise" min="0.01" max="0.5" step="0.01" value="0.1">
                        <span id="esikfProcessNoiseValue">0.1</span>
                    </div>
                    <div class="control-group">
                        <label>观测噪声 \(\sigma_R\):</label>
                        <input type="range" id="esikfObsNoise" min="0.1" max="2.0" step="0.1" value="0.5">
                        <span id="esikfObsNoiseValue">0.5</span>
                    </div>
                    <div class="control-group">
                        <label>初始协方差 \(P_0\):</label>
                        <input type="range" id="esikfInitCov" min="0.1" max="5.0" step="0.1" value="1.0">
                        <span id="esikfInitCovValue">1.0</span>
                    </div>
                    <div class="control-group">
                        <label>迭代次数 \(N_{\text{iter}}\):</label>
                        <input type="range" id="esikfIterations" min="1" max="5" step="1" value="2">
                        <span id="esikfIterationsValue">2</span>
                    </div>
                    <button class="btn" onclick="startESIKFSimulation()">开始ESIKF仿真</button>
                    <button class="btn" onclick="resetESIKFSimulation()">重置</button>
                </div>
                <!-- 参数调整指南 -->
                <div class="math-formula" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">🎯 仿真参数调整指南</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 13px; color: #e0e0e0;">
                        <div>
                            <h5 style="color: #ff6b6b; margin-bottom: 10px;">系统参数影响：</h5>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #ff8a8a;">提高 f<sub>IMU</sub></strong>：IMU采样频率增大 → 状态更新更频繁，估计精度提升，但计算量增大</li>
                                <li><strong style="color: #ff8a8a;">降低 f<sub>IMU</sub></strong>：IMU采样频率减小 → 状态更新稀疏，估计精度下降，但计算量减小</li>
                                <li><strong style="color: #ff8a8a;">提高 f<sub>cam</sub></strong>：相机观测频率增大 → 更频繁的观测更新，轨迹估计更准确</li>
                                <li><strong style="color: #ff8a8a;">降低 f<sub>cam</sub></strong>：相机观测频率减小 → 观测更新稀疏，依赖预测模型更多</li>
                            </ul>
                        </div>
                        <div>
                            <h5 style="color: #ffaa00; margin-bottom: 10px;">噪声参数影响：</h5>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #ffcc66;">增大 σ<sub>Q</sub></strong>：过程噪声增大 → 系统不确定性增加，协方差增长更快</li>
                                <li><strong style="color: #ffcc66;">减小 σ<sub>Q</sub></strong>：过程噪声减小 → 系统更信任运动模型，协方差增长缓慢</li>
                                <li><strong style="color: #ffcc66;">增大 σ<sub>R</sub></strong>：观测噪声增大 → 更不信任观测，卡尔曼增益减小</li>
                                <li><strong style="color: #ffcc66;">减小 σ<sub>R</sub></strong>：观测噪声减小 → 更信任观测，卡尔曼增益增大</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <h5 style="color: #4ecdc4; margin-bottom: 10px;">算法参数影响：</h5>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 13px; color: #e0e0e0;">
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #66d9d9;">增大 P<sub>0</sub></strong>：初始协方差增大 → 初始不确定性高，收敛需要更多观测</li>
                                <li><strong style="color: #66d9d9;">减小 P<sub>0</sub></strong>：初始协方差减小 → 初始估计更自信，但可能过度自信</li>
                            </ul>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                <li><strong style="color: #66d9d9;">增大 N<sub>iter</sub></strong>：迭代次数增加 → ESIKF收敛更充分，精度提高但计算量增大</li>
                                <li><strong style="color: #66d9d9;">减小 N<sub>iter</sub></strong>：迭代次数减少 → 计算速度快，但可能未充分收敛</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: rgba(78, 205, 196, 0.1); border-left: 3px solid #4ecdc4; border-radius: 4px;">
                        <strong style="color: #4ecdc4;">💡 实验建议：</strong>
                        <span style="font-size: 12px;">先调整系统参数观察滤波频率影响，再调整噪声参数观察不确定性传播，最后调整算法参数优化收敛性能。</span>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-top: 20px;">
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">状态估计轨迹</h4>
                        <canvas id="esikfTrajectoryCanvas" class="visualization-canvas" style="height: 280px;"></canvas>
                    </div>
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">协方差演化</h4>
                        <canvas id="esikfCovarianceCanvas" class="visualization-canvas" style="height: 280px;"></canvas>
                    </div>
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">参数影响分析</h4>
                        <canvas id="esikfVariableCanvas" class="visualization-canvas" style="height: 280px;"></canvas>
                    </div>
                </div>
                <!-- 可视化与数学模型对应关系 -->
                <div class="math-formula" style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">🔗 可视化与数学模型对应关系</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 14px; color: #e0e0e0;">
                        <div>
                            <strong>仿真参数与数学变量对应：</strong>
                            <ul style="margin-top: 10px; font-size: 13px; color: #e0e0e0;">
                                <li><strong style="color: #ff8a8a;">f<sub>IMU</sub></strong> ↔ IMU采样频率（预测步频率）</li>
                                <li><strong style="color: #ff8a8a;">f<sub>cam</sub></strong> ↔ 相机观测频率（更新步频率）</li>
                                <li><strong style="color: #ffcc66;">σ<sub>Q</sub></strong> ↔ 过程噪声协方差矩阵 Q<sub>k</sub></li>
                                <li><strong style="color: #ffcc66;">σ<sub>R</sub></strong> ↔ 观测噪声协方差矩阵 R<sub>k</sub></li>
                                <li><strong style="color: #66d9d9;">P<sub>0</sub></strong> ↔ 初始状态协方差矩阵</li>
                                <li><strong style="color: #66d9d9;">N<sub>iter</sub></strong> ↔ ESIKF迭代次数</li>
                            </ul>
                        </div>
                        <div>
                            <strong>ESIKF核心方程：</strong>
                            <ul style="margin-top: 10px; font-size: 14px;">
                                <li>$$\mathbf{X} = \mathbf{X}_{\text{nom}} \boxplus \delta\mathbf{X}$$</li>
                                <li>$$\mathbf{P}_{k|k-1} = \mathbf{F}_k \mathbf{P}_{k-1|k-1} \mathbf{F}_k^T + \mathbf{Q}_k$$</li>
                                <li>$$\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}_k^T (\mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^T + \mathbf{R}_k)^{-1}$$</li>
                                <li>$$\delta\mathbf{X}_k = \mathbf{K}_k (\mathbf{z}_k - \mathbf{h}(\mathbf{X}_{k|k-1}))$$</li>
                                <li>$$\mathbf{P}_{k|k} = (\mathbf{I} - \mathbf{K}_k \mathbf{H}_k) \mathbf{P}_{k|k-1}$$</li>
                                <li>$$\mathbf{X}_{k|k} = \mathbf{X}_{k|k-1} \boxplus \delta\mathbf{X}_k$$</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <!-- ESIKF参数调整指南 -->
                <div class="math-formula" style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">📊 ESIKF参数调整指南</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; font-size: 13px; color: #e0e0e0;">
                        <div>
                            <strong style="color: #ff8a8a;">频率参数调整：</strong>
                            <ul style="margin-top: 8px; font-size: 12px;">
                                <li><strong>IMU频率 f<sub>IMU</sub> ↑</strong>：预测更频繁，状态传播更精细，但计算量增加</li>
                                <li><strong>IMU频率 f<sub>IMU</sub> ↓</strong>：预测粗糙，状态传播误差增大，但计算效率高</li>
                                <li><strong>相机频率 f<sub>cam</sub> ↑</strong>：观测更新更频繁，滤波精度提高，但计算负荷重</li>
                                <li><strong>相机频率 f<sub>cam</sub> ↓</strong>：观测更新稀疏，滤波可能发散，但计算轻量</li>
                            </ul>
                        </div>
                        <div>
                            <strong style="color: #ffcc66;">噪声参数调整：</strong>
                            <ul style="margin-top: 8px; font-size: 12px;">
                                <li><strong>过程噪声 σ<sub>Q</sub> ↑</strong>：系统不确定性增加，协方差增大，滤波更保守</li>
                                <li><strong>过程噪声 σ<sub>Q</sub> ↓</strong>：系统过于自信，可能导致滤波发散或锁定</li>
                                <li><strong>观测噪声 σ<sub>R</sub> ↑</strong>：观测信任度降低，更依赖预测，滤波更平滑</li>
                                <li><strong>观测噪声 σ<sub>R</sub> ↓</strong>：观测信任度提高，更依赖观测，滤波反应灵敏</li>
                            </ul>
                        </div>
                        <div>
                            <strong style="color: #66d9d9;">算法参数调整：</strong>
                            <ul style="margin-top: 8px; font-size: 12px;">
                                <li><strong>初始协方差 P<sub>0</sub> ↑</strong>：初始不确定性大，滤波收敛慢，但更鲁棒</li>
                                <li><strong>初始协方差 P<sub>0</sub> ↓</strong>：初始过于自信，可能导致收敛到局部最优</li>
                                <li><strong>迭代次数 N<sub>iter</sub> ↑</strong>：更精确的线性化，滤波精度提高，但计算量大</li>
                                <li><strong>迭代次数 N<sub>iter</sub> ↓</strong>：线性化误差大，滤波精度降低，但计算效率高</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                        <strong style="color: #4ecdc4;">💡 实验建议：</strong>
                        <span style="font-size: 13px; color: #e0e0e0;">
                            先调整噪声参数观察滤波稳定性，再优化频率参数平衡精度与效率，最后调整迭代次数提高精度。
                            注意观察协方差迹和创新向量的变化趋势。
                        </span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 光度误差仿真 -->
        <div class="section">
            <h2>📸 R3LIVE光度误差仿真</h2>
            
            <div class="interactive-demo">
                <h3>直接光度误差优化可视化</h3>
                <div class="demo-controls">
                    <div class="control-group">
                        <label>图像帧数 \(N_i\):</label>
                        <input type="range" id="frameCount" min="2" max="10" step="1" value="5">
                        <span id="frameCountValue">5</span> 帧
                    </div>
                    <div class="control-group">
                        <label>像素集合大小 \(|\Omega_i|\):</label>
                        <input type="range" id="pixelSetSize" min="50" max="500" step="50" value="200">
                        <span id="pixelSetSizeValue">200</span> 像素
                    </div>
                    <div class="control-group">
                        <label>参考帧噪声 \(\sigma_{I_{ref}}\):</label>
                        <input type="range" id="refImageNoise" min="0.1" max="5.0" step="0.1" value="1.0">
                        <span id="refImageNoiseValue">1.0</span>
                    </div>
                    <div class="control-group">
                        <label>变换矩阵扭动 \(\delta\mathbf{T}\):</label>
                        <input type="range" id="transformPerturbation" min="0.01" max="0.5" step="0.01" value="0.1">
                        <span id="transformPerturbationValue">0.1</span> rad
                    </div>
                    <div class="control-group">
                        <label>优化步长 \(\alpha\):</label>
                        <input type="range" id="optStepSize" min="0.01" max="0.5" step="0.01" value="0.1">
                        <span id="optStepSizeValue">0.1</span>
                    </div>
                    <button class="btn" onclick="startPhotometricSimulation()">开始光度优化</button>
                    <button class="btn" onclick="alert('JavaScript正常工作'); console.log('JavaScript正常工作')">测试JS</button>
                    <button class="btn" onclick="resetPhotometricSimulation()">重置</button>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                    <div>
                        <h4 style="color: #4ecdc4; margin-bottom: 10px;">图像匹配</h4>
                        <canvas id="photometricMatchCanvas" class="visualization-canvas" style="height: 350px;"></canvas>
                    </div>
                    <div>
                        <h4 style="color: #4ecdc4; margin-bottom: 10px;">光度误差收敛</h4>
                        <canvas id="photometricErrorCanvas" class="visualization-canvas" style="height: 350px;"></canvas>
                    </div>
                </div>
                <div class="math-formula" style="margin-top: 20px;">
                    <h4 style="color: #4ecdc4;">光度误差模型（与仿真变量一一对应）</h4>
                    <p><strong>直接光度误差函数：</strong></p>
                    <p>$$E_{\text{photo}} = \sum_{i=1}^{N_i} \sum_{\mathbf{p} \in \Omega_i} \| I_i(\mathbf{p}) - I_{\text{ref}}(\pi(\mathbf{T} \mathbf{P}(\mathbf{p}))) + \mathcal{N}(0, \sigma_{I_{\text{ref}}}^2) \|^2$$</p>
                    <p><strong>变量对应关系：</strong></p>
                    <ul style="color: #333333; margin: 10px 0; padding-left: 20px;">
                        <li>$N_i$ - 图像帧数（仿真参数：图像帧数）</li>
                        <li>$|\Omega_i|$ - 每帧中的像素集合大小（仿真参数：像素集合大小）</li>
                        <li>$\sigma_{I_{\text{ref}}}$ - 参考帧噪声标准差（仿真参数：参考帧噪声）</li>
                        <li>$\mathbf{T} = \mathbf{T}_0 + \delta\mathbf{T}$ - 变换矩阵扭动（仿真参数：变换扭动）</li>
                        <li>$\alpha$ - 优化步长（仿真参数：优化步长）</li>
                    </ul>
                    <p><strong>雅可比矩阵（对变换矩阵求导）：</strong></p>
                    <p>$$\mathbf{J} = \frac{\partial E_{\text{photo}}}{\partial \delta\mathbf{T}} = -2\sum_{i=1}^{N_i} \sum_{\mathbf{p} \in \Omega_i} [I_i(\mathbf{p}) - I_{\text{ref}}(\pi(\mathbf{T} \mathbf{P}))] \cdot \nabla I_{\text{ref}} \cdot \frac{\partial \pi}{\partial \mathbf{P}} \cdot \frac{\partial \mathbf{P}}{\partial \delta\mathbf{T}}$$</p>
                    <p><strong>优化更新规则：</strong></p>
                    <p>$$\delta\mathbf{T}_{k+1} = \delta\mathbf{T}_k - \alpha \cdot (\mathbf{J}^T\mathbf{J})^{-1}\mathbf{J}^T \mathbf{r}$$</p>
                </div>
                
                <div class="math-formula" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">🎯 仿真参数调整指南（与数学模型一一对应）</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <h5 style="color: #ffffff; margin-bottom: 10px;">📊 图像数据参数</h5>
                            <ul style="margin: 0; padding-left: 20px; color: #ffffff; line-height: 1.6;">
                                <li><strong>N_i (图像帧数) ↑：</strong>计算复杂度增加，估计精度提升</li>
                                <li><strong>N_i (图像帧数) ↓：</strong>计算速度快，估计精度下降</li>
                                <li><strong>|Ω_i| (像素集合) ↑：</strong>光度信息丰富，内存开销增加</li>
                                <li><strong>|Ω_i| (像素集合) ↓：</strong>内存节约，信息量不足</li>
                                <li><strong>σ_{I_{ref}} (参考帧噪声) ↑：</strong>鲁棒性测试，收敛难度增加</li>
                                <li><strong>σ_{I_{ref}} (参考帧噪声) ↓：</strong>理想条件，收敛速度提升</li>
                            </ul>
                        </div>
                        <div>
                            <h5 style="color: #4ecdc4; margin-bottom: 10px;">⚙️ 优化参数</h5>
                            <ul style="margin: 0; padding-left: 20px; color: #ffffff; line-height: 1.6;">
                                <li><strong>δT (变换扭动) ↑：</strong>初始误差大，测试收敛域</li>
                                <li><strong>δT (变换扭动) ↓：</strong>初始误差小，局部优化</li>
                                <li><strong>α (优化步长) ↑：</strong>收敛速度快，可能振荡</li>
                                <li><strong>α (优化步长) ↓：</strong>收敛稳定，速度较慢</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                        <h6 style="color: #66d9d9; margin-bottom: 8px;">💡 推荐配置策略（与数学模型对应）</h6>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; font-size: 12px;">
                            <div style="color: #ffffff;"><strong style="color: #ff6b6b;">高精度模式：</strong>N_i=8-10, |Ω_i|=400+, σ_{I_{ref}}=0.5, δT=0.05, α=0.05</div>
                            <div style="color: #ffffff;"><strong style="color: #4ecdc4;">高效率模式：</strong>N_i=3-5, |Ω_i|=100-200, σ_{I_{ref}}=1.0, δT=0.1, α=0.15</div>
                            <div style="color: #ffffff;"><strong style="color: #ffaa00;">高鲁棒性模式：</strong>N_i=5-7, |Ω_i|=200-300, σ_{I_{ref}}=2.0, δT=0.2, α=0.08</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- R3LIVE协同优化仿真 -->
        <div class="section">
            <h2>🚀 R3LIVE协同优化仿真</h2>
            
            <div class="interactive-demo">
                <h3>IMU预积分+LIO子系统+VIO子系统协同优化</h3>
                <div class="demo-controls">
                    <div class="control-group">
                        <label>LiDAR频率 \(f_{LiDAR}\):</label>
                        <input type="range" id="lidarFreq" min="10" max="100" step="10" value="20">
                        <span id="lidarFreqValue">20</span> Hz
                    </div>
                    <div class="control-group">
                        <label>相机频率 \(f_{cam}\):</label>
                        <input type="range" id="r3liveCamFreq" min="10" max="60" step="10" value="30">
                        <span id="r3liveCamFreqValue">30</span> Hz
                    </div>
                    <div class="control-group">
                        <label>点云密度 \(N_{cloud}\):</label>
                        <input type="range" id="pointCloudDensity" min="100" max="1000" step="100" value="500">
                        <span id="pointCloudDensityValue">500</span> 点
                    </div>
                    <div class="control-group">
                        <label>优化权重 \(\lambda_{opt}\):</label>
                        <input type="range" id="optimizationWeight" min="0.1" max="2.0" step="0.1" value="1.0">
                        <span id="optimizationWeightValue">1.0</span>
                    </div>
                    <button class="btn" onclick="startR3LIVESimulation()">开始R3LIVE仿真</button>
                    <button class="btn" onclick="resetR3LIVESimulation()">重置</button>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">LIO子系统：点云配准与位姿估计</h4>
                        <canvas id="lioCanvas" class="visualization-canvas" style="height: 350px;"></canvas>
                    </div>
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">VIO子系统：光度误差优化</h4>
                        <canvas id="vioCanvas" class="visualization-canvas" style="height: 350px;"></canvas>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">协同优化：相机位姿演化</h4>
                        <canvas id="poseOptCanvas" class="visualization-canvas" style="height: 350px;"></canvas>
                    </div>
                    <div>
                        <h4 style="color: white; margin-bottom: 10px;">系统状态：误差收敛分析</h4>
                        <canvas id="systemStateCanvas" class="visualization-canvas" style="height: 350px;"></canvas>
                    </div>
                </div>
                <div class="math-formula" style="margin-top: 20px;">
                    <h4>R3LIVE协同优化数学模型</h4>
                    <p>LIO子系统目标函数：$$\mathcal{L}_{LIO} = \sum_{i} \|\mathbf{f}_i(\mathbf{X}_i, \mathbf{P}_i)\|^2_{\mathbf{\Sigma}_{LiDAR}}$$</p>
                    <p>VIO子系统目标函数：$$\mathcal{L}_{VIO} = \sum_{\mathbf{p}} \|I(\mathbf{p}) - I_{ref}(\pi(\mathbf{T}_{cw} \mathbf{P}))\|^2_{\mathbf{\Sigma}_{cam}}$$</p>
                    <p>协同优化目标函数：$$\mathcal{L}_{total} = \mathcal{L}_{LIO} + \lambda_{opt} \mathcal{L}_{VIO} + \mathcal{L}_{IMU}$$</p>
                    <p>其中：$$\mathcal{L}_{IMU} = \sum_{k} \|\mathbf{r}_{IMU}(\mathbf{X}_k, \mathbf{X}_{k+1})\|^2_{\mathbf{\Sigma}_{IMU}}$$</p>
                </div>
            </div>
        </div>

        <!-- 核心公式总结 -->
        <div class="section">
            <h2>📝 核心公式总结</h2>
            
            <div class="math-formula">
                <h4>1. 状态转移方程</h4>
                $$\mathbf{x}_{k+1} = \mathbf{F}_k \mathbf{x}_k + \mathbf{B}_k \mathbf{u}_k + \mathbf{w}_k$$
            </div>

            <div class="math-formula">
                <h4>2. 观测方程</h4>
                $$\mathbf{z}_k = \mathbf{H}_k \mathbf{x}_k + \mathbf{v}_k$$
            </div>

            <div class="math-formula">
                <h4>3. 因子图优化目标函数</h4>
                $$\min_{\mathbf{X}} \sum_{i} \rho_i(\|\mathbf{r}_i(\mathbf{X})\|^2_{\mathbf{\Sigma}_i})$$
            </div>

            <div class="math-formula">
                <h4>4. R3LIVE光度误差</h4>
                $$E = \sum_{\mathbf{p}} \|I(\mathbf{p}) - I_{ref}(\pi(\mathbf{T}_{cw} \mathbf{P}))\|^2$$
            </div>
        </div>
    </div>

    <script>
        // MathJax配置
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };

        // 卡尔曼滤波器可视化
        let canvas, ctx;
        let animationId;
        let time = 0;
        let truePosition = [];
        let noisyObservations = [];
        let filteredEstimates = [];
        let isRunning = false;

        function initCanvas() {
            canvas = document.getElementById('kalmanCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        function startSimulation() {
            if (isRunning) return;
            
            isRunning = true;
            time = 0;
            truePosition = [];
            noisyObservations = [];
            filteredEstimates = [];
            
            let x = 0; // 状态估计
            let P = 1; // 误差协方差
            
            function simulate() {
                const Q = parseFloat(document.getElementById('processNoise').value);
                const R = parseFloat(document.getElementById('observationNoise').value);
                
                document.getElementById('qValue').textContent = Q;
                document.getElementById('rValue').textContent = R;
                
                // 真实位置（正弦波）
                const truePos = Math.sin(time * 0.1) * 100 + canvas.height / 2;
                truePosition.push(truePos);
                
                // 添加噪声的观测
                const noisyObs = truePos + (Math.random() - 0.5) * R * 30;
                noisyObservations.push(noisyObs);
                
                // 卡尔曼滤波器预测
                P = P + Q;
                
                // 卡尔曼滤波器更新
                const K = P / (P + R);
                x = x + K * (noisyObs - x);
                P = (1 - K) * P;
                
                filteredEstimates.push(x);
                
                drawVisualization();
                
                time++;
                if (time < 300 && isRunning) {
                    animationId = requestAnimationFrame(simulate);
                } else {
                    isRunning = false;
                }
            }
            
            simulate();
        }

        function drawVisualization() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            // 绘制真实轨迹
            if (truePosition.length > 1) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i < truePosition.length; i++) {
                    const x = (i / truePosition.length) * canvas.width;
                    if (i === 0) {
                        ctx.moveTo(x, truePosition[i]);
                    } else {
                        ctx.lineTo(x, truePosition[i]);
                    }
                }
                ctx.stroke();
            }
            
            // 绘制噪声观测
            ctx.fillStyle = '#ff6b6b';
            for (let i = 0; i < noisyObservations.length; i++) {
                const x = (i / Math.max(noisyObservations.length - 1, 1)) * canvas.width;
                ctx.beginPath();
                ctx.arc(x, noisyObservations[i], 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // 绘制滤波估计
            if (filteredEstimates.length > 1) {
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < filteredEstimates.length; i++) {
                    const x = (i / filteredEstimates.length) * canvas.width;
                    if (i === 0) {
                        ctx.moveTo(x, filteredEstimates[i]);
                    } else {
                        ctx.lineTo(x, filteredEstimates[i]);
                    }
                }
                ctx.stroke();
            }
            
            // 绘制图例
            ctx.font = '14px Arial';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('真实轨迹', 10, 30);
            ctx.fillStyle = '#ff6b6b';
            ctx.fillText('噪声观测', 10, 50);
            ctx.fillStyle = '#4ecdc4';
            ctx.fillText('卡尔曼滤波估计', 10, 70);
        }

        function resetSimulation() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            time = 0;
            truePosition = [];
            noisyObservations = [];
            filteredEstimates = [];
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        // IMU预积分仿真变量
        let imuSimRunning = false;
        let imuPosCanvas, imuOriCanvas, imuVarCanvas;
        let imuPosCtx, imuOriCtx, imuVarCtx;
        let imuTime = 0;
        let imuPosition = {x: 0, y: 0, z: 0};
        let imuVelocity = {x: 0, y: 0, z: 0};
        let imuOrientation = {roll: 0, pitch: 0, yaw: 0};
        let imuTrajectory = [];
        let orientationHistory = [];
        
        // IMU预积分相关变量
        let deltaPosition = {x: 0, y: 0, z: 0};  // Δp_ij
        let deltaVelocity = {x: 0, y: 0, z: 0};  // Δv_ij
        let deltaRotation = {roll: 0, pitch: 0, yaw: 0};  // ΔR_ij
        let accBias = {x: 0, y: 0, z: 0};  // b_a
        let gyroBias = {x: 0, y: 0, z: 0};  // b_g
        let preintegratedMeasurements = [];
        let lastPreintTime = 0;

        // 因子图优化仿真变量
        let factorGraphRunning = false;
        let factorGraphCanvas, convergenceCanvas;
        let fgCtx, convCtx;
        let nodes = [];
        let factors = [];
        let optimizationHistory = [];
        let currentIteration = 0;

        // IMU预积分仿真函数
        function startIMUSimulation() {
            if (imuSimRunning) return;
            
            initIMUCanvas();
            imuSimRunning = true;
            imuTime = 0;
            imuPosition = {x: 0, y: 0, z: 0};
            imuVelocity = {x: 0, y: 0, z: 0};
            imuOrientation = {roll: 0, pitch: 0, yaw: 0};
            imuTrajectory = [];
            orientationHistory = [];
            
            simulateIMU();
        }

        function initIMUCanvas() {
            imuPosCanvas = document.getElementById('imuPositionCanvas');
            imuOriCanvas = document.getElementById('imuOrientationCanvas');
            imuVarCanvas = document.getElementById('imuVariableCanvas');
            if (!imuPosCanvas || !imuOriCanvas || !imuVarCanvas) return;
            
            imuPosCanvas.width = imuPosCanvas.offsetWidth;
            imuPosCanvas.height = imuPosCanvas.offsetHeight;
            imuOriCanvas.width = imuOriCanvas.offsetWidth;
            imuOriCanvas.height = imuOriCanvas.offsetHeight;
            imuVarCanvas.width = imuVarCanvas.offsetWidth;
            imuVarCanvas.height = imuVarCanvas.offsetHeight;
            
            imuPosCtx = imuPosCanvas.getContext('2d');
            imuOriCtx = imuOriCanvas.getContext('2d');
            imuVarCtx = imuVarCanvas.getContext('2d');
        }

        function simulateIMU() {
            if (!imuSimRunning) return;
            
            const sigma_a = parseFloat(document.getElementById('accNoise').value);
            const sigma_g = parseFloat(document.getElementById('gyroNoise').value);
            const freq = parseFloat(document.getElementById('imuFreq').value);
            const b_a = parseFloat(document.getElementById('accBias').value);
            const b_g = parseFloat(document.getElementById('gyroBias').value);
            const preintInterval = parseFloat(document.getElementById('preintTime').value);
            const dt = 1.0 / freq;
            
            // 更新IMU偏置（随机游走模型）
            accBias.x += (Math.random() - 0.5) * 0.001 * dt;
            accBias.y += (Math.random() - 0.5) * 0.001 * dt;
            accBias.z += (Math.random() - 0.5) * 0.001 * dt;
            
            gyroBias.x += (Math.random() - 0.5) * 0.0001 * dt;
            gyroBias.y += (Math.random() - 0.5) * 0.0001 * dt;
            gyroBias.z += (Math.random() - 0.5) * 0.0001 * dt;
            
            // 真实IMU测量值（含偏置）
            const trueAcc = {
                x: Math.sin(imuTime * 0.1) * 2 + b_a,
                y: Math.cos(imuTime * 0.15) * 1.5 + b_a,
                z: -9.81 + Math.sin(imuTime * 0.05) * 0.5 + b_a
            };
            
            const trueGyro = {
                x: Math.sin(imuTime * 0.2) * 0.5 + b_g,
                y: Math.cos(imuTime * 0.25) * 0.3 + b_g,
                z: Math.sin(imuTime * 0.1) * 0.8 + b_g
            };
            
            // 添加高斯白噪声 n_a ~ N(0, σ_a²I), n_g ~ N(0, σ_g²I)
            const n_a = {
                x: (Math.random() - 0.5) * sigma_a * 2,
                y: (Math.random() - 0.5) * sigma_a * 2,
                z: (Math.random() - 0.5) * sigma_a * 2
            };
            
            const n_g = {
                x: (Math.random() - 0.5) * sigma_g * 2,
                y: (Math.random() - 0.5) * sigma_g * 2,
                z: (Math.random() - 0.5) * sigma_g * 2
            };
            
            // 观测到的IMU数据: ã = a + b_a + n_a
            const measuredAcc = {
                x: trueAcc.x + accBias.x + n_a.x,
                y: trueAcc.y + accBias.y + n_a.y,
                z: trueAcc.z + accBias.z + n_a.z
            };
            
            const measuredGyro = {
                x: trueGyro.x + gyroBias.x + n_g.x,
                y: trueGyro.y + gyroBias.y + n_g.y,
                z: trueGyro.z + gyroBias.z + n_g.z
            };
            
            // IMU预积分计算: Δv_ij = ∫(R_t(ã_t - b_at - n_a) - g)dt
            const correctedAcc = {
                x: measuredAcc.x - accBias.x,
                y: measuredAcc.y - accBias.y,
                z: measuredAcc.z - accBias.z + 9.81  // 补偿重力
            };
            
            const correctedGyro = {
                x: measuredGyro.x - gyroBias.x,
                y: measuredGyro.y - gyroBias.y,
                z: measuredGyro.z - gyroBias.z
            };
            
            // 预积分速度更新: Δv += corrected_acc * dt
            deltaVelocity.x += correctedAcc.x * dt;
            deltaVelocity.y += correctedAcc.y * dt;
            deltaVelocity.z += correctedAcc.z * dt;
            
            // 预积分位置更新: Δp += Δv * dt + 0.5 * corrected_acc * dt²
            deltaPosition.x += deltaVelocity.x * dt + 0.5 * correctedAcc.x * dt * dt;
            deltaPosition.y += deltaVelocity.y * dt + 0.5 * correctedAcc.y * dt * dt;
            deltaPosition.z += deltaVelocity.z * dt + 0.5 * correctedAcc.z * dt * dt;
            
            // 预积分旋转更新: ΔR *= Exp((ω̃ - b_g - n_g) * dt)
            deltaRotation.roll += correctedGyro.x * dt;
            deltaRotation.pitch += correctedGyro.y * dt;
            deltaRotation.yaw += correctedGyro.z * dt;
            
            // 更新全局状态用于可视化
            imuVelocity.x += correctedAcc.x * dt;
            imuVelocity.y += correctedAcc.y * dt;
            imuVelocity.z += correctedAcc.z * dt;
            
            imuPosition.x += imuVelocity.x * dt;
            imuPosition.y += imuVelocity.y * dt;
            imuPosition.z += imuVelocity.z * dt;
            
            imuOrientation.roll += correctedGyro.x * dt;
            imuOrientation.pitch += correctedGyro.y * dt;
            imuOrientation.yaw += correctedGyro.z * dt;
            
            // 每隔预积分时间间隔保存预积分测量值
            if (imuTime - lastPreintTime >= preintInterval) {
                preintegratedMeasurements.push({
                    time: imuTime,
                    deltaP: {...deltaPosition},
                    deltaV: {...deltaVelocity},
                    deltaR: {...deltaRotation},
                    bias_a: {...accBias},
                    bias_g: {...gyroBias}
                });
                
                // 重置预积分变量
                deltaPosition = {x: 0, y: 0, z: 0};
                deltaVelocity = {x: 0, y: 0, z: 0};
                deltaRotation = {roll: 0, pitch: 0, yaw: 0};
                lastPreintTime = imuTime;
                
                if (preintegratedMeasurements.length > 50) {
                    preintegratedMeasurements.shift();
                }
            }
            
            imuTrajectory.push({x: imuPosition.x, y: imuPosition.y, z: imuPosition.z});
            orientationHistory.push({...imuOrientation});
            
            if (imuTrajectory.length > 500) {
                imuTrajectory.shift();
                orientationHistory.shift();
            }
            
            drawIMUVisualization();
            
            imuTime += dt;
            if (imuTime < 30 && imuSimRunning) {
                requestAnimationFrame(simulateIMU);
            } else {
                imuSimRunning = false;
            }
        }

        function drawIMUVisualization() {
            if (!imuPosCtx || !imuOriCtx) return;
            
            // 绘制位置轨迹
            imuPosCtx.clearRect(0, 0, imuPositionCanvas.width, imuPositionCanvas.height);
            
            // 绘制背景网格
            imuPosCtx.strokeStyle = '#333333';
            imuPosCtx.lineWidth = 0.5;
            const gridSize = 30;
            for (let i = 0; i <= imuPositionCanvas.width; i += gridSize) {
                imuPosCtx.beginPath();
                imuPosCtx.moveTo(i, 0);
                imuPosCtx.lineTo(i, imuPositionCanvas.height);
                imuPosCtx.stroke();
            }
            for (let i = 0; i <= imuPositionCanvas.height; i += gridSize) {
                imuPosCtx.beginPath();
                imuPosCtx.moveTo(0, i);
                imuPosCtx.lineTo(imuPositionCanvas.width, i);
                imuPosCtx.stroke();
            }
            
            // 绘制中心十字线
            imuPosCtx.strokeStyle = '#666666';
            imuPosCtx.lineWidth = 1;
            imuPosCtx.beginPath();
            imuPosCtx.moveTo(imuPositionCanvas.width / 2, 0);
            imuPosCtx.lineTo(imuPositionCanvas.width / 2, imuPositionCanvas.height);
            imuPosCtx.moveTo(0, imuPositionCanvas.height / 2);
            imuPosCtx.lineTo(imuPositionCanvas.width, imuPositionCanvas.height / 2);
            imuPosCtx.stroke();
            
            if (imuTrajectory.length > 1) {
                // 绘制轨迹阴影（增加深度）
                imuPosCtx.strokeStyle = 'rgba(78, 205, 196, 0.3)';
                imuPosCtx.lineWidth = 6;
                imuPosCtx.beginPath();
                for (let i = 0; i < imuTrajectory.length; i++) {
                    const scale = 4; // 增大缩放系数
                    const x = imuTrajectory[i].x * scale + imuPositionCanvas.width / 2;
                    const y = -imuTrajectory[i].y * scale + imuPositionCanvas.height / 2; // Y轴反向
                    if (i === 0) {
                        imuPosCtx.moveTo(x, y);
                    } else {
                        imuPosCtx.lineTo(x, y);
                    }
                }
                imuPosCtx.stroke();
                
                // 绘制主轨迹线
                imuPosCtx.strokeStyle = '#4ecdc4';
                imuPosCtx.lineWidth = 3;
                imuPosCtx.beginPath();
                for (let i = 0; i < imuTrajectory.length; i++) {
                    const scale = 4;
                    const x = imuTrajectory[i].x * scale + imuPositionCanvas.width / 2;
                    const y = -imuTrajectory[i].y * scale + imuPositionCanvas.height / 2;
                    if (i === 0) {
                        imuPosCtx.moveTo(x, y);
                    } else {
                        imuPosCtx.lineTo(x, y);
                    }
                }
                imuPosCtx.stroke();
                
                // 绘制轨迹点（每10个点显示一个）
                imuPosCtx.fillStyle = '#45b7d1';
                for (let i = 0; i < imuTrajectory.length; i += 10) {
                    const scale = 4;
                    const x = imuTrajectory[i].x * scale + imuPositionCanvas.width / 2;
                    const y = -imuTrajectory[i].y * scale + imuPositionCanvas.height / 2;
                    imuPosCtx.beginPath();
                    imuPosCtx.arc(x, y, 2, 0, 2 * Math.PI);
                    imuPosCtx.fill();
                }
            }
            
            // 绘制起始位置
            if (imuTrajectory.length > 0) {
                const start = imuTrajectory[0];
                const scale = 4;
                const x = start.x * scale + imuPositionCanvas.width / 2;
                const y = -start.y * scale + imuPositionCanvas.height / 2;
                imuPosCtx.fillStyle = '#00ff00';
                imuPosCtx.beginPath();
                imuPosCtx.arc(x, y, 8, 0, 2 * Math.PI);
                imuPosCtx.fill();
                
                // 绘制当前位置
                const current = imuTrajectory[imuTrajectory.length - 1];
                const currentX = current.x * scale + imuPositionCanvas.width / 2;
                const currentY = -current.y * scale + imuPositionCanvas.height / 2;
                imuPosCtx.fillStyle = '#ff6b6b';
                imuPosCtx.beginPath();
                imuPosCtx.arc(currentX, currentY, 8, 0, 2 * Math.PI);
                imuPosCtx.fill();
                
                // 绘制速度矢量
                if (imuTrajectory.length > 1) {
                    const prev = imuTrajectory[imuTrajectory.length - 2];
                    const vx = (current.x - prev.x) * 20; // 放大速度显示
                    const vy = -(current.y - prev.y) * 20;
                    
                    imuPosCtx.strokeStyle = '#ff6b6b';
                    imuPosCtx.lineWidth = 2;
                    imuPosCtx.beginPath();
                    imuPosCtx.moveTo(currentX, currentY);
                    imuPosCtx.lineTo(currentX + vx, currentY + vy);
                    imuPosCtx.stroke();
                    
                    // 绘制箭头
                    const angle = Math.atan2(vy, vx);
                    const arrowLength = 8;
                    imuPosCtx.beginPath();
                    imuPosCtx.moveTo(currentX + vx, currentY + vy);
                    imuPosCtx.lineTo(currentX + vx - arrowLength * Math.cos(angle - 0.3), currentY + vy - arrowLength * Math.sin(angle - 0.3));
                    imuPosCtx.moveTo(currentX + vx, currentY + vy);
                    imuPosCtx.lineTo(currentX + vx - arrowLength * Math.cos(angle + 0.3), currentY + vy - arrowLength * Math.sin(angle + 0.3));
                    imuPosCtx.stroke();
                }
            }
            
            // 绘制信息文字
            imuPosCtx.fillStyle = '#ffffff';
            imuPosCtx.font = 'bold 12px Arial';
            imuPosCtx.fillText('绿色: 起始位置', 10, 20);
            imuPosCtx.fillText('红色: 当前位置', 10, 35);
            imuPosCtx.fillText('青色: 轨迹路径', 10, 50);
            imuPosCtx.fillText('红箭头: 速度方向', 10, 65);
            
            if (imuTrajectory.length > 0) {
                const current = imuTrajectory[imuTrajectory.length - 1];
                imuPosCtx.fillText(`位置 \u{1d70d}: (${current.x.toFixed(2)}, ${current.y.toFixed(2)}, ${current.z.toFixed(2)})`, 10, 85);
                imuPosCtx.fillText(`速度 \u{1d70f}: (${imuVelocity.x.toFixed(2)}, ${imuVelocity.y.toFixed(2)}, ${imuVelocity.z.toFixed(2)})`, 10, 100);
                imuPosCtx.fillText(`预积分位移 Δpᵢⱼ: (${deltaPosition.x.toFixed(3)}, ${deltaPosition.y.toFixed(3)}, ${deltaPosition.z.toFixed(3)})`, 10, 115);
                imuPosCtx.fillText(`预积分速度 Δvᵢⱼ: (${deltaVelocity.x.toFixed(3)}, ${deltaVelocity.y.toFixed(3)}, ${deltaVelocity.z.toFixed(3)})`, 10, 130);
                imuPosCtx.fillText(`预积分旋转 ΔRᵢⱼ: (${deltaRotation.roll.toFixed(3)}, ${deltaRotation.pitch.toFixed(3)}, ${deltaRotation.yaw.toFixed(3)})`, 10, 145);
                imuPosCtx.fillText(`加速度计偏置 bₐ: (${accBias.x.toFixed(4)}, ${accBias.y.toFixed(4)}, ${accBias.z.toFixed(4)})`, 10, 160);
                imuPosCtx.fillText(`陀螺仪偏置 bₘ: (${gyroBias.x.toFixed(4)}, ${gyroBias.y.toFixed(4)}, ${gyroBias.z.toFixed(4)})`, 10, 175);
                imuPosCtx.fillText(`噪声标准差 σₐ=${parseFloat(document.getElementById('accNoise').value).toFixed(3)}, σₘ=${parseFloat(document.getElementById('gyroNoise').value).toFixed(3)}`, 10, 190);
                imuPosCtx.fillText(`时间 t: ${imuTime.toFixed(2)}s, 预积分数: ${preintegratedMeasurements.length}`, 10, 205);
            }
            
            // 绘制姿态变化
            imuOriCtx.clearRect(0, 0, imuOrientationCanvas.width, imuOrientationCanvas.height);
            
            if (orientationHistory.length > 1) {
                const colors = ['#ff6b6b', '#00ff00', '#ffaa00'];
                const labels = ['Roll (φ)', 'Pitch (θ)', 'Yaw (ψ)'];
                const keys = ['roll', 'pitch', 'yaw'];
                
                for (let j = 0; j < 3; j++) {
                    imuOriCtx.strokeStyle = colors[j];
                    imuOriCtx.lineWidth = 2;
                    imuOriCtx.beginPath();
                    
                    for (let i = 0; i < orientationHistory.length; i++) {
                        const x = (i / orientationHistory.length) * imuOrientationCanvas.width;
                        const y = imuOrientationCanvas.height / 2 - orientationHistory[i][keys[j]] * 50;
                        if (i === 0) {
                            imuOriCtx.moveTo(x, y);
                        } else {
                            imuOriCtx.lineTo(x, y);
                        }
                    }
                    imuOriCtx.stroke();
                    
                    // 绘制标签
                    imuOriCtx.fillStyle = colors[j];
                    imuOriCtx.font = '12px Arial';
                    imuOriCtx.fillText(labels[j], 10, 20 + j * 20);
                }
                
                // 显示当前姿态和预积分旋转信息
                if (orientationHistory.length > 0) {
                    const current = orientationHistory[orientationHistory.length - 1];
                    imuOriCtx.fillStyle = '#ffffff';
                    imuOriCtx.font = 'bold 12px Arial';
                    imuOriCtx.fillText('当前姿态 R:', 10, 100);
                    imuOriCtx.fillText(`φ = ${(current.roll * 180 / Math.PI).toFixed(2)}°`, 10, 115);
                    imuOriCtx.fillText(`θ = ${(current.pitch * 180 / Math.PI).toFixed(2)}°`, 10, 130);
                    imuOriCtx.fillText(`ψ = ${(current.yaw * 180 / Math.PI).toFixed(2)}°`, 10, 145);
                    
                    imuOriCtx.fillText('预积分旋转 ΔRᵢⱼ:', 10, 170);
                    imuOriCtx.fillText(`Δφ = ${(deltaRotation.roll * 180 / Math.PI).toFixed(3)}°`, 10, 185);
                    imuOriCtx.fillText(`Δθ = ${(deltaRotation.pitch * 180 / Math.PI).toFixed(3)}°`, 10, 200);
                    imuOriCtx.fillText(`Δψ = ${(deltaRotation.yaw * 180 / Math.PI).toFixed(3)}°`, 10, 215);
                    
                    // 显示陀螺仪测量值影响
                    const sigma_g = parseFloat(document.getElementById('gyroNoise').value);
                    const b_g = parseFloat(document.getElementById('gyroBias').value);
                    imuOriCtx.fillText(`陀螺仪噪声影响 σₘ = ${sigma_g.toFixed(3)} rad/s`, 10, 240);
                    imuOriCtx.fillText(`陀螺仪偏置影响 bₘ = ${b_g.toFixed(3)} rad/s`, 10, 255);
                }
            }
            
            // 绘制变量影响分析
            drawVariableImpactAnalysis();
        }
        
        function drawVariableImpactAnalysis() {
            if (!imuVarCtx) return;
            
            imuVarCtx.clearRect(0, 0, imuVarCanvas.width, imuVarCanvas.height);
            
            // 获取当前参数值
            const sigma_a = parseFloat(document.getElementById('accNoise').value);
            const sigma_g = parseFloat(document.getElementById('gyroNoise').value);
            const b_a = parseFloat(document.getElementById('accBias').value);
            const b_g = parseFloat(document.getElementById('gyroBias').value);
            const freq = parseFloat(document.getElementById('imuFreq').value);
            const preintInterval = parseFloat(document.getElementById('preintTime').value);
            
            // 绘制标题
            imuVarCtx.fillStyle = '#ffffff';
            imuVarCtx.font = 'bold 14px Arial';
            imuVarCtx.fillText('参数对预积分的影响', 10, 20);
            
            // 绘制参数影响条形图
            const barHeight = 15;
            const barSpacing = 25;
            const maxBarWidth = imuVarCanvas.width - 150;
            
            // 加速度计噪声影响
            const accNoiseImpact = sigma_a / 0.5; // 归一化到[0,1]
            imuVarCtx.fillStyle = '#ff6b6b';
            imuVarCtx.fillRect(120, 40, maxBarWidth * accNoiseImpact, barHeight);
            imuVarCtx.fillStyle = '#ffffff';
            imuVarCtx.font = '12px Arial';
            imuVarCtx.fillText(`σₐ 影响:`, 10, 52);
            imuVarCtx.fillText(`${(accNoiseImpact * 100).toFixed(1)}%`, maxBarWidth + 130, 52);
            
            // 陀螺仪噪声影响
            const gyroNoiseImpact = sigma_g / 0.3;
            imuVarCtx.fillStyle = '#00ff00';
            imuVarCtx.fillRect(120, 65, maxBarWidth * gyroNoiseImpact, barHeight);
            imuVarCtx.fillStyle = '#ffffff';
            imuVarCtx.fillText(`σₘ 影响:`, 10, 77);
            imuVarCtx.fillText(`${(gyroNoiseImpact * 100).toFixed(1)}%`, maxBarWidth + 130, 77);
            
            // 加速度计偏置影响
            const accBiasImpact = Math.abs(b_a) / 0.5;
            imuVarCtx.fillStyle = '#ffaa00';
            imuVarCtx.fillRect(120, 90, maxBarWidth * accBiasImpact, barHeight);
            imuVarCtx.fillStyle = '#ffffff';
            imuVarCtx.fillText(`bₐ 影响:`, 10, 102);
            imuVarCtx.fillText(`${(accBiasImpact * 100).toFixed(1)}%`, maxBarWidth + 130, 102);
            
            // 陀螺仪偏置影响
            const gyroBiasImpact = Math.abs(b_g) / 0.1;
            imuVarCtx.fillStyle = '#4ecdc4';
            imuVarCtx.fillRect(120, 115, maxBarWidth * gyroBiasImpact, barHeight);
            imuVarCtx.fillStyle = '#ffffff';
            imuVarCtx.fillText(`bₘ 影响:`, 10, 127);
            imuVarCtx.fillText(`${(gyroBiasImpact * 100).toFixed(1)}%`, maxBarWidth + 130, 127);
            
            // 预积分精度指标
            imuVarCtx.fillStyle = '#ffffff';
            imuVarCtx.font = 'bold 12px Arial';
            imuVarCtx.fillText('预积分精度指标:', 10, 160);
            
            // 计算总误差影响
            const totalError = Math.sqrt(accNoiseImpact*accNoiseImpact + gyroNoiseImpact*gyroNoiseImpact + 
                                       accBiasImpact*accBiasImpact + gyroBiasImpact*gyroBiasImpact);
            const accuracy = Math.max(0, 1 - totalError/2);
            
            imuVarCtx.font = '11px Arial';
            imuVarCtx.fillText(`位移精度: ${(accuracy * 100).toFixed(1)}%`, 10, 180);
            imuVarCtx.fillText(`速度精度: ${((accuracy + 0.1) * 100).toFixed(1)}%`, 10, 195);
            imuVarCtx.fillText(`姿态精度: ${((accuracy + 0.05) * 100).toFixed(1)}%`, 10, 210);
            
            // 实时预积分数据
            if (preintegratedMeasurements.length > 0) {
                const latest = preintegratedMeasurements[preintegratedMeasurements.length - 1];
                imuVarCtx.fillStyle = '#ffffff';
                imuVarCtx.font = 'bold 12px Arial';
                imuVarCtx.fillText('当前预积分值:', 10, 240);
                imuVarCtx.font = '10px Arial';
                imuVarCtx.fillText(`|Δpᵢⱼ| = ${Math.sqrt(latest.deltaP.x*latest.deltaP.x + latest.deltaP.y*latest.deltaP.y + latest.deltaP.z*latest.deltaP.z).toFixed(3)}m`, 10, 255);
                imuVarCtx.fillText(`|Δvᵢⱼ| = ${Math.sqrt(latest.deltaV.x*latest.deltaV.x + latest.deltaV.y*latest.deltaV.y + latest.deltaV.z*latest.deltaV.z).toFixed(3)}m/s`, 10, 270);
            }
        }

        function resetIMUSimulation() {
            imuSimRunning = false;
            imuTime = 0;
            imuTrajectory = [];
            orientationHistory = [];
            if (imuPosCtx) imuPosCtx.clearRect(0, 0, imuPositionCanvas.width, imuPositionCanvas.height);
            if (imuOriCtx) imuOriCtx.clearRect(0, 0, imuOrientationCanvas.width, imuOrientationCanvas.height);
        }

        // 因子图优化仿真函数
        function startFactorGraphSimulation() {
            if (factorGraphRunning) return;
            
            initFactorGraphCanvas();
            factorGraphRunning = true;
            currentIteration = 0;
            optimizationHistory = [];
            
            generateFactorGraph();
            optimizeFactorGraph();
        }

        function initFactorGraphCanvas() {
            factorGraphCanvas = document.getElementById('factorGraphCanvas');
            convergenceCanvas = document.getElementById('convergenceCanvas');
            const parameterCanvas = document.getElementById('factorGraphVariableCanvas');
            
            if (!factorGraphCanvas || !convergenceCanvas || !parameterCanvas) return;
            
            // 初始化三个可视化面板（与数学模型对应）
            factorGraphCanvas.width = factorGraphCanvas.offsetWidth;
            factorGraphCanvas.height = factorGraphCanvas.offsetHeight;
            convergenceCanvas.width = convergenceCanvas.offsetWidth;
            convergenceCanvas.height = convergenceCanvas.offsetHeight;
            parameterCanvas.width = parameterCanvas.offsetWidth;
            parameterCanvas.height = parameterCanvas.offsetHeight;
            
            fgCtx = factorGraphCanvas.getContext('2d');
            convCtx = convergenceCanvas.getContext('2d');
            
            // 初始化参数影响分析面板
            drawFactorGraphParameterAnalysis();
        }

        function generateFactorGraph() {
            // 获取仿真参数（与数学模型严格对应）
            const N = parseInt(document.getElementById('nodeCount').value);  // 节点数量
            const sigma_obs = parseFloat(document.getElementById('obsNoise').value);  // 观测噪声标准差
            
            nodes = [];
            factors = [];
            
            // 生成N个节点（对应数学模型中的状态变量x_i）
            for (let i = 0; i < N; i++) {
                const t = i / (N - 1) * 2 * Math.PI;
                nodes.push({
                    id: i,
                    // 真实状态 x_i^*（ground truth）
                    trueX: Math.cos(t) * 100 + factorGraphCanvas.width / 2,
                    trueY: Math.sin(t) * 80 + factorGraphCanvas.height / 2,
                    // 初始估计 x_i^0（带噪声的初始猜测）
                    estimatedX: Math.cos(t) * 100 + factorGraphCanvas.width / 2 + (Math.random() - 0.5) * 50,
                    estimatedY: Math.sin(t) * 80 + factorGraphCanvas.height / 2 + (Math.random() - 0.5) * 50
                });
            }
            
            // 生成里程计因子（对应数学模型中的f_i函数）
            for (let i = 0; i < N - 1; i++) {
                factors.push({
                    from: i,
                    to: i + 1,
                    type: 'odometry',
                    // 信息矩阵 Ω_i = Σ_i^(-1) = (σ_obs^2 * I)^(-1)
                    weight: 1.0 / (sigma_obs * sigma_obs)
                });
            }
            
            // 添加回环检测因子（对应数学模型中的回环约束）
            for (let i = 0; i < N; i++) {
                for (let j = i + 3; j < N; j++) {
                    const dist = Math.sqrt(
                        Math.pow(nodes[i].trueX - nodes[j].trueX, 2) +
                        Math.pow(nodes[i].trueY - nodes[j].trueY, 2)
                    );
                    if (dist < 80 && Math.random() < 0.3) {
                        factors.push({
                            from: i,
                            to: j,
                            type: 'loop',
                            // 回环约束的信息矩阵（权重稍低）
                            weight: 0.5 / (sigma_obs * sigma_obs)
                        });
                    }
                }
            }
        }

        function optimizeFactorGraph() {
            if (!factorGraphRunning) return;
            
            // 获取优化参数（与数学模型严格对应）
            const k_max = parseInt(document.getElementById('optIterations').value);  // 最大迭代次数
            const lambda_damp = parseFloat(document.getElementById('dampingFactor').value);  // 阻尼因子
            const epsilon_conv = parseFloat(document.getElementById('convergenceThreshold').value);  // 收敛阈值
            const alpha_step = parseFloat(document.getElementById('stepFactor').value);  // 步长因子
            
            if (currentIteration < k_max) {
                // 高斯-牛顿优化步骤（对应数学模型中的迭代公式）
                let F_total = 0;  // 总目标函数值 F(X)
                
                // 计算每个节点的梯度和海塞矩阵近似
                for (let node of nodes) {
                    let grad_x = 0, grad_y = 0;  // 梯度向量 ∇F
                    let hessian_approx = 0;  // 海塞矩阵近似 H ≈ J^T Ω J
                    
                    // 遍历所有与当前节点相关的因子
                    for (let factor of factors) {
                        if (factor.from === node.id || factor.to === node.id) {
                            const other = factor.from === node.id ? nodes[factor.to] : nodes[factor.from];
                            
                            // 计算误差函数 e_i = f_i(x_i, x_j) - z_ij
                            const dx = node.estimatedX - other.estimatedX;
                            const dy = node.estimatedY - other.estimatedY;
                            const current_dist = Math.sqrt(dx * dx + dy * dy);
                            
                            const target_dist = Math.sqrt(
                                Math.pow(node.trueX - other.trueX, 2) +
                                Math.pow(node.trueY - other.trueY, 2)
                            );
                            
                            const e_i = current_dist - target_dist;  // 误差函数值
                            F_total += 0.5 * e_i * e_i * factor.weight;  // F(X) = Σ(1/2 * e_i^T * Ω_i * e_i)
                            
                            // 计算雅可比矩阵 J_i = ∂e_i/∂x_i
                            const direction = factor.from === node.id ? 1 : -1;
                            const J_x = direction * dx / Math.max(current_dist, 1e-6);  // ∂e_i/∂x
                            const J_y = direction * dy / Math.max(current_dist, 1e-6);  // ∂e_i/∂y
                            
                            // 累积梯度：∇F = Σ(J_i^T * Ω_i * e_i)
                            grad_x += J_x * factor.weight * e_i;
                            grad_y += J_y * factor.weight * e_i;
                            
                            // 累积海塞矩阵近似：H ≈ Σ(J_i^T * Ω_i * J_i)
                            hessian_approx += factor.weight * (J_x * J_x + J_y * J_y);
                        }
                    }
                    
                    // Levenberg-Marquardt更新：Δx = -(H + λI)^(-1) * ∇F
                    const damped_hessian = hessian_approx + lambda_damp;  // H + λI
                    const delta_x = -alpha_step * grad_x / Math.max(damped_hessian, 1e-6);
                    const delta_y = -alpha_step * grad_y / Math.max(damped_hessian, 1e-6);
                    
                    // 更新状态估计：x_{k+1} = x_k + Δx
                    node.estimatedX += delta_x;
                    node.estimatedY += delta_y;
                }
                
                optimizationHistory.push(F_total);
                
                // 检查收敛条件：||∇F|| < ε_conv
                const gradient_norm = Math.sqrt(F_total);
                if (gradient_norm < epsilon_conv && currentIteration > 5) {
                    factorGraphRunning = false;
                    console.log(`因子图优化收敛于第${currentIteration}次迭代，梯度范数: ${gradient_norm.toFixed(6)}`);
                }
                
                drawFactorGraphVisualization();
                
                currentIteration++;
                setTimeout(() => optimizeFactorGraph(), 100);
            } else {
                factorGraphRunning = false;
                console.log(`因子图优化达到最大迭代次数${k_max}`);
            }
        }

        function drawFactorGraphVisualization() {
            if (!fgCtx || !convCtx) return;
            
            // 绘制因子图结构（对应数学模型中的图结构G=(V,E)）
            fgCtx.clearRect(0, 0, factorGraphCanvas.width, factorGraphCanvas.height);
            
            // 绘制因子边（对应数学模型中的约束函数f_i）
            for (let factor of factors) {
                const fromNode = nodes[factor.from];
                const toNode = nodes[factor.to];
                
                // 里程计约束（蓝绿色）vs 回环约束（红色）
                fgCtx.strokeStyle = factor.type === 'odometry' ? '#4ecdc4' : '#ff6b6b';
                fgCtx.lineWidth = factor.type === 'odometry' ? 2 : 1;
                fgCtx.beginPath();
                fgCtx.moveTo(fromNode.estimatedX, fromNode.estimatedY);
                fgCtx.lineTo(toNode.estimatedX, toNode.estimatedY);
                fgCtx.stroke();
            }
            
            // 绘制状态节点（对应数学模型中的状态变量x_i）
            for (let node of nodes) {
                // 真实状态 x_i^*（绿色小圆）
                fgCtx.fillStyle = '#00ff00';
                fgCtx.beginPath();
                fgCtx.arc(node.trueX, node.trueY, 4, 0, 2 * Math.PI);
                fgCtx.fill();
                
                // 当前估计 x_i^k（蓝色大圆）
                fgCtx.fillStyle = '#45b7d1';
                fgCtx.beginPath();
                fgCtx.arc(node.estimatedX, node.estimatedY, 6, 0, 2 * Math.PI);
                fgCtx.fill();
                
                // 估计误差线（白色虚线）
                fgCtx.strokeStyle = '#ffffff';
                fgCtx.lineWidth = 1;
                fgCtx.setLineDash([2, 2]);
                fgCtx.beginPath();
                fgCtx.moveTo(node.trueX, node.trueY);
                fgCtx.lineTo(node.estimatedX, node.estimatedY);
                fgCtx.stroke();
                fgCtx.setLineDash([]);
            }
            
            // 绘制目标函数收敛曲线（对应数学模型中F(X)的变化）
            convCtx.clearRect(0, 0, convergenceCanvas.width, convergenceCanvas.height);
            
            if (optimizationHistory.length > 1) {
                // 绘制F(X)收敛曲线
                convCtx.strokeStyle = '#4ecdc4';
                convCtx.lineWidth = 2;
                convCtx.beginPath();
                
                const F_max = Math.max(...optimizationHistory);  // 最大目标函数值
                for (let k = 0; k < optimizationHistory.length; k++) {
                    const x = (k / Math.max(optimizationHistory.length - 1, 1)) * convergenceCanvas.width;
                    const y = convergenceCanvas.height - (optimizationHistory[k] / F_max) * convergenceCanvas.height * 0.8;
                    if (k === 0) {
                        convCtx.moveTo(x, y);
                    } else {
                        convCtx.lineTo(x, y);
                    }
                }
                convCtx.stroke();
                
                // 显示当前迭代状态（与数学模型变量对应）
                convCtx.fillStyle = '#ffffff';
                convCtx.font = '12px Arial';
                const k_current = currentIteration;  // 当前迭代次数k
                const F_current = optimizationHistory[optimizationHistory.length - 1] || 0;  // 当前目标函数值F(X^k)
                convCtx.fillText(`迭代次数 k: ${k_current}`, 10, 20);
                convCtx.fillText(`目标函数 F(X): ${F_current.toFixed(4)}`, 10, 40);
                
                // 显示收敛状态
                const epsilon_conv = parseFloat(document.getElementById('convergenceThreshold').value);
                const gradient_norm = Math.sqrt(F_current);
                const converged = gradient_norm < epsilon_conv;
                convCtx.fillStyle = converged ? '#00ff00' : '#ffaa00';
                convCtx.fillText(`梯度范数: ${gradient_norm.toFixed(6)}`, 10, 60);
                convCtx.fillText(`收敛状态: ${converged ? '已收敛' : '未收敛'}`, 10, 80);
            }
            
            // 绘制参数影响分析面板（第三个可视化面板）
            drawFactorGraphParameterAnalysis();
        }
        
        function drawFactorGraphParameterAnalysis() {
            const paramCanvas = document.getElementById('factorGraphVariableCanvas');
            if (!paramCanvas) return;
            
            const paramCtx = paramCanvas.getContext('2d');
            paramCtx.clearRect(0, 0, paramCanvas.width, paramCanvas.height);
            
            // 获取当前参数值（与数学模型严格对应）
            const N = parseInt(document.getElementById('nodeCount').value);
            const sigma_obs = parseFloat(document.getElementById('obsNoise').value);
            const k_max = parseInt(document.getElementById('optIterations').value);
            const lambda_damp = parseFloat(document.getElementById('dampingFactor').value);
            const epsilon_conv = parseFloat(document.getElementById('convergenceThreshold').value);
            const alpha_step = parseFloat(document.getElementById('stepFactor').value);
            
            // 绘制参数影响分析图表
            paramCtx.fillStyle = '#ffffff';
            paramCtx.font = '14px Arial';
            paramCtx.fillText('参数影响分析', 10, 20);
            
            // 绘制参数条形图（显示当前参数值的影响）
            const params = [
                {name: 'N (节点数)', value: N, max: 20, color: '#ff6b6b', impact: 'complexity'},
                {name: 'σ_obs (噪声)', value: sigma_obs, max: 1.0, color: '#ffaa00', impact: 'stability'},
                {name: 'k_max (迭代)', value: k_max, max: 100, color: '#4ecdc4', impact: 'accuracy'},
                {name: 'λ_damp (阻尼)', value: lambda_damp, max: 10.0, color: '#ff8a8a', impact: 'stability'},
                {name: 'ε_conv (收敛)', value: epsilon_conv, max: 0.1, color: '#66d9d9', impact: 'precision'},
                {name: 'α_step (步长)', value: alpha_step, max: 2.0, color: '#ffcc66', impact: 'speed'}
            ];
            
            const barHeight = 25;
            const barSpacing = 35;
            const startY = 40;
            
            for (let i = 0; i < params.length; i++) {
                const param = params[i];
                const y = startY + i * barSpacing;
                const barWidth = (param.value / param.max) * (paramCanvas.width - 120);
                
                // 绘制参数名称
                paramCtx.fillStyle = '#ffffff';
                paramCtx.font = '11px Arial';
                paramCtx.fillText(param.name, 10, y + 15);
                
                // 绘制参数条
                paramCtx.fillStyle = param.color;
                paramCtx.fillRect(10, y + 18, barWidth, barHeight - 10);
                
                // 绘制参数值
                paramCtx.fillStyle = '#ffffff';
                paramCtx.font = '10px Arial';
                paramCtx.fillText(param.value.toFixed(3), barWidth + 15, y + 25);
                
                // 绘制影响类型
                const impactColors = {
                    'complexity': '#ff6b6b',
                    'stability': '#ffaa00', 
                    'accuracy': '#4ecdc4',
                    'precision': '#66d9d9',
                    'speed': '#ffcc66'
                };
                paramCtx.fillStyle = impactColors[param.impact];
                paramCtx.fillText(`[${param.impact}]`, barWidth + 60, y + 25);
            }
            
            // 绘制影响说明
            paramCtx.fillStyle = '#ffffff';
            paramCtx.font = '10px Arial';
            paramCtx.fillText('影响类型：', 10, paramCanvas.height - 40);
            paramCtx.fillText('complexity-复杂度  stability-稳定性  accuracy-精度', 10, paramCanvas.height - 25);
            paramCtx.fillText('precision-精密度  speed-速度', 10, paramCanvas.height - 10);
        }

        function resetFactorGraphSimulation() {
            factorGraphRunning = false;
            currentIteration = 0;
            optimizationHistory = [];
            nodes = [];
            factors = [];
            if (fgCtx) fgCtx.clearRect(0, 0, factorGraphCanvas.width, factorGraphCanvas.height);
            if (convCtx) convCtx.clearRect(0, 0, convergenceCanvas.width, convergenceCanvas.height);
        }

        // 光度误差仿真变量
        let photometricRunning = false;
        let photometricCanvas, photometricErrorCanvas;
        let photoCtx, errorCtx;
        let photometricHistory = [];
        let currentPhotoIteration = 0;
        let imageFeatures = [];
        let referenceImage = null;
        let currentImage = null;

        function initPhotometricSimulation() {
            photometricCanvas = document.getElementById('photometricMatchCanvas');
            photometricErrorCanvas = document.getElementById('photometricErrorCanvas');
            
            if (photometricCanvas && photometricErrorCanvas) {
                photoCtx = photometricCanvas.getContext('2d');
                errorCtx = photometricErrorCanvas.getContext('2d');
                
                // 设置canvas尺寸
                photometricCanvas.width = photometricCanvas.offsetWidth;
                photometricCanvas.height = photometricCanvas.offsetHeight;
                photometricErrorCanvas.width = photometricErrorCanvas.offsetWidth;
                photometricErrorCanvas.height = photometricErrorCanvas.offsetHeight;
            }
        }

        function generateImageFeatures() {
            // 获取与数学模型严格对应的参数
            const N_i = parseInt(document.getElementById('frameCount').value);  // 图像帧数 N_i
            const pixelSetSize = parseInt(document.getElementById('pixelSetSize').value);  // 像素集合大小 |Ω_i|
            const sigma_I_ref = parseFloat(document.getElementById('refImageNoise').value);  // 参考帧噪声 σ_{I_ref}
            const deltaT = parseFloat(document.getElementById('transformPerturbation').value);  // 变换扭动 δT
            const alpha = parseFloat(document.getElementById('optStepSize').value);  // 优化步长 α
            
            // 初始化像素集合 Ω_i = {p_j | j = 1, ..., |Ω_i|}
            imageFeatures = [];
            
            // 生成参考图像 I_ref 中的像素点（对应数学模型中的参考帧）
            for (let i = 0; i < pixelSetSize; i++) {
                const feature = {
                    id: i,
                    // 参考图像中的像素位置 p_i^{ref} = [u_i^{ref}, v_i^{ref}]^T
                    refX: Math.random() * (photometricCanvas.width - 40) + 20,   // u_i^{ref}
                    refY: Math.random() * (photometricCanvas.height - 40) + 20,  // v_i^{ref}
                    refIntensity: Math.random() * 255,  // I_ref(p_i^{ref}) - 参考图像在p_i处的光强值
                    
                    // 当前图像中的像素位置 p_i^{cur} = [u_i^{cur}, v_i^{cur}]^T
                    currentX: 0,  // u_i^{cur}
                    currentY: 0,  // v_i^{cur}
                    currentIntensity: 0,  // I_cur(p_i^{cur}) - 当前图像在p_i处的光强值
                    
                    // 特征点匹配状态
                    matched: false,
                    
                    // 添加数学模型中的关键变量
                    photometricError: 0,  // r_i = I_cur(p_i) - I_ref(π(T_{cw} * P_i)) - 光度误差
                    jacobian: [0, 0],     // J_i = ∂r_i/∂T - 雅可比矩阵
                    weight: 1.0,          // w_i - 特征点权重
                    depth: Math.random() * 5 + 1  // d_i - 特征点深度（模拟3D点）
                };
                
                // 模拟相机运动和图像噪声（对应数学模型中的观测噪声）
                // 添加高斯噪声 n_i ~ N(0, σ_{I_{ref}}^2) 和变换扭动 δT
                const noiseX = (Math.random() - 0.5) * sigma_I_ref * 2 + deltaT * 10;  // u方向噪声+扭动
                const noiseY = (Math.random() - 0.5) * sigma_I_ref * 2 + deltaT * 10;  // v方向噪声+扭动
                const noiseIntensity = (Math.random() - 0.5) * sigma_I_ref * 10;  // 参考帧光强噪声
                
                // 初始化当前图像中的特征点位置（加入噪声和变换）
                feature.currentX = feature.refX + noiseX;
                feature.currentY = feature.refY + noiseY;
                feature.currentIntensity = Math.max(0, Math.min(255, feature.refIntensity + noiseIntensity));
                
                // 计算初始光度误差 r_i = I_cur(p_i) - I_ref(p_i)
                feature.photometricError = feature.currentIntensity - feature.refIntensity;
                
                imageFeatures.push(feature);
            }
        }

        function startPhotometricSimulation() {
            console.log('=== 开始光度仿真函数被调用 ===');
            
            if (photometricRunning) {
                console.log('仿真已在运行，退出');
                return;
            }
            
            console.log('步骤 1: 初始化Canvas');
            // 初始化Canvas
            initPhotometricSimulation();
            
            console.log('步骤 2: 检查Canvas初始化状态');
            console.log('photoCtx:', photoCtx);
            console.log('errorCtx:', errorCtx);
            
            // 检查Canvas是否初始化成功
            if (!photoCtx || !errorCtx) {
                console.error('错误：Canvas初始化失败');
                console.log('photometricCanvas:', document.getElementById('photometricMatchCanvas'));
                console.log('photometricErrorCanvas:', document.getElementById('photometricErrorCanvas'));
                alert('Canvas初始化失败，请检查页面加载状态');
                return;
            }
            
            console.log('步骤 3: 设置仿真参数');
            photometricRunning = true;
            currentPhotoIteration = 0;
            photometricHistory = [];
            
            console.log('步骤 4: 生成特征点');
            generateImageFeatures();
            console.log('生成的特征点数量:', imageFeatures.length);
            
            console.log('步骤 5: 开始优化迭代');
            optimizePhotometricError();
            
            console.log('=== 光度仿真启动完成 ===');
        }

        function optimizePhotometricError() {
            if (!photometricRunning) return;
            
            // 优化参数（与数学模型严格对应）
            const maxIterations = 30;  // 最大迭代次数 N_max
            const alpha = parseFloat(document.getElementById('optStepSize').value);  // 优化步长 α
            const N_i = parseInt(document.getElementById('frameCount').value);  // 图像帧数 N_i
            const pixelSetSize = parseInt(document.getElementById('pixelSetSize').value);  // 像素集合大小 |Ω_i|
            const sigma_I_ref = parseFloat(document.getElementById('refImageNoise').value);  // 参考帧噪声 σ_{I_ref}
            const deltaT = parseFloat(document.getElementById('transformPerturbation').value);  // 变换扭动 δT
            
            // 调试信息
            console.log(`开始迭代 ${currentPhotoIteration}: imageFeatures.length = ${imageFeatures.length}`);
            
            // 检查是否有特征点数据
            if (imageFeatures.length === 0) {
                console.error('错误：imageFeatures数组为空，重新生成特征点');
                generateImageFeatures();
                if (imageFeatures.length === 0) {
                    console.error('无法生成特征点，停止仿真');
                    photometricRunning = false;
                    return;
                }
            }
            
            if (currentPhotoIteration < maxIterations) {
                // 初始化总光度误差 E_photo = ∑_i ||r_i||^2
                let E_photo = 0;
                let totalWeight = 0;
                let matchedFeatures = 0;
                
                // 对每个特征点计算光度误差和雅可比（对应数学模型中的残差计算）
                for (let i = 0; i < imageFeatures.length; i++) {
                    const feature = imageFeatures[i];
                    
                    // 计算光度误差 r_i = I_cur(p_i) - I_ref(π(T_{cw} * P_i))
                    // 简化为直接像素对比（实际中需要投影变换）
                    const r_i = feature.currentIntensity - feature.refIntensity;
                    feature.photometricError = r_i;
                    
                    // 计算像素位置误差（用于模拟几何约束）
                    const delta_u = feature.currentX - feature.refX;  // u方向位置误差
                    const delta_v = feature.currentY - feature.refY;  // v方向位置误差
                    
                    // 计算雅可比矩阵 J_i = ∂r_i/∂T（简化为像素梯度）
                    // 实际中需要计算对相机位姿 T 的偏导数
                    const gradientX = (Math.random() - 0.5) * 0.1;  // ∂r_i/∂t_x 简化
                    const gradientY = (Math.random() - 0.5) * 0.1;  // ∂r_i/∂t_y 简化
                    feature.jacobian = [gradientX, gradientY];
                    
                    // 计算特征点权重 w_i（基于误差大小的鲁棒权重）
                    const errorMagnitude = Math.abs(r_i) + Math.sqrt(delta_u * delta_u + delta_v * delta_v);
                    feature.weight = 1.0 / (1.0 + errorMagnitude / (sigma_I_ref * 2));  // Huber权重
                    
                    // 计算加权光度误差 E_i = w_i * ||r_i||^2
                    const E_i = feature.weight * (r_i * r_i + 0.1 * (delta_u * delta_u + delta_v * delta_v));
                    E_photo += E_i;
                    totalWeight += feature.weight;
                    
                    // Gauss-Newton优化更新（对应数学模型中的参数更新）
                    // 更新规则：θ_{k+1} = θ_k - α * (J^T * J)^{-1} * J^T * r
                    const updateX = -alpha * feature.jacobian[0] * r_i * feature.weight;
                    const updateY = -alpha * feature.jacobian[1] * r_i * feature.weight;
                    const updateIntensity = -alpha * r_i * 0.01 * feature.weight;
                    
                    // 更新特征点位置和光强
                    feature.currentX += updateX - alpha * delta_u * 0.1;
                    feature.currentY += updateY - alpha * delta_v * 0.1;
                    feature.currentIntensity += updateIntensity;
                    
                    // 边界约束（保证像素在有效范围内）
                    feature.currentX = Math.max(20, Math.min(photometricCanvas.width - 20, feature.currentX));
                    feature.currentY = Math.max(20, Math.min(photometricCanvas.height - 20, feature.currentY));
                    feature.currentIntensity = Math.max(0, Math.min(255, feature.currentIntensity));
                    
                    // 判断特征点匹配状态（基于误差阈值）
                    const pixelDistance = Math.sqrt(delta_u * delta_u + delta_v * delta_v);
                    const intensityDiff = Math.abs(r_i);
                    feature.matched = pixelDistance < 5 && intensityDiff < sigma_I_ref * 2;
                    
                    if (feature.matched) matchedFeatures++;
                }
                
                // 记录优化历史（对应数学模型中的收敛曲线）
                const historyData = {
                    iteration: currentPhotoIteration,
                    totalError: Math.max(E_photo, 0.1), // 确保最小值不为0
                    averageError: Math.max(E_photo / Math.max(imageFeatures.length, 1), 0.01),
                    matchedRatio: Math.max(matchedFeatures / Math.max(imageFeatures.length, 1), 0),
                    totalWeight: Math.max(totalWeight, 0.1)
                };
                photometricHistory.push(historyData);
                
                // 调试信息（可在控制台查看）
                if (currentPhotoIteration % 5 === 0) {
                    console.log(`迭代 ${currentPhotoIteration}: 总误差=${E_photo.toFixed(3)}, 平均误差=${historyData.averageError.toFixed(3)}, 匹配率=${historyData.matchedRatio.toFixed(3)}`);
                }
                
                drawPhotometricVisualization();
                drawPhotometricParameterAnalysis();  // 调用参数影响分析面板
                drawPhotometricParameterGuide();     // 调用参数调节指南面板
                
                currentPhotoIteration++;
                setTimeout(() => optimizePhotometricError(), 150);
            } else {
                photometricRunning = false;
            }
        }

        function drawPhotometricVisualization() {
            if (!photoCtx || !errorCtx) return;
            
            // 绘制图像匹配面板（对应数学模型中的特征点匹配）
            photoCtx.clearRect(0, 0, photometricCanvas.width, photometricCanvas.height);
            
            // 绘制背景网格和坐标轴
            photoCtx.strokeStyle = '#333';
            photoCtx.lineWidth = 0.5;
            for (let i = 0; i < photometricCanvas.width; i += 20) {
                photoCtx.beginPath();
                photoCtx.moveTo(i, 0);
                photoCtx.lineTo(i, photometricCanvas.height);
                photoCtx.stroke();
            }
            for (let i = 0; i < photometricCanvas.height; i += 20) {
                photoCtx.beginPath();
                photoCtx.moveTo(0, i);
                photoCtx.lineTo(photometricCanvas.width, i);
                photoCtx.stroke();
            }
            
            // 绘制特征点（对应数学模型中的像素点 p_i）
            for (let i = 0; i < imageFeatures.length; i++) {
                const feature = imageFeatures[i];
                
                // 绘制参考图像中的特征点 p_i^{ref}（绿色）
                photoCtx.fillStyle = '#00ff00';
                photoCtx.beginPath();
                photoCtx.arc(feature.refX, feature.refY, 4, 0, 2 * Math.PI);
                photoCtx.fill();
                
                // 绘制当前图像中的特征点 p_i^{cur}（根据匹配状态显示不同颜色）
                const errorMagnitude = Math.abs(feature.photometricError);
                const alpha = Math.min(feature.weight, 1.0);  // 根据权重调整透明度
                
                if (feature.matched) {
                    photoCtx.fillStyle = `rgba(69, 183, 209, ${alpha})`; // 蓝色，匹配成功
                } else {
                    photoCtx.fillStyle = `rgba(255, 107, 107, ${alpha})`; // 红色，未匹配
                }
                
                const pointSize = 4 + Math.min(feature.weight * 4, 6);  // 根据权重调整点大小
                photoCtx.beginPath();
                photoCtx.arc(feature.currentX, feature.currentY, pointSize, 0, 2 * Math.PI);
                photoCtx.fill();
                
                // 绘制光度误差连接线（对应数学模型中的残差 r_i）
                const lineWidth = Math.max(1, Math.min(errorMagnitude / 20, 3));
                photoCtx.strokeStyle = feature.matched ? 
                    `rgba(78, 205, 196, ${alpha})` : `rgba(255, 153, 153, ${alpha})`;
                photoCtx.lineWidth = lineWidth;
                photoCtx.beginPath();
                photoCtx.moveTo(feature.refX, feature.refY);
                photoCtx.lineTo(feature.currentX, feature.currentY);
                photoCtx.stroke();
                
                // 绘制特征点ID（仅显示前10个）
                if (i < 10) {
                    photoCtx.fillStyle = '#ffffff';
                    photoCtx.font = '8px Arial';
                    photoCtx.fillText(i.toString(), feature.currentX + 8, feature.currentY - 8);
                }
            }
            
            // 绘制详细图例和数学模型对应
            photoCtx.fillStyle = '#ffffff';
            photoCtx.font = '11px Arial';
            photoCtx.fillText('R3LIVE光度误差优化可视化', 10, 15);
            
            photoCtx.font = '9px Arial';
            photoCtx.fillStyle = '#00ff00';
            photoCtx.fillText('● 参考图像 I_ref(p_i)', 10, 30);
            photoCtx.fillStyle = '#45b7d1';
            photoCtx.fillText('● 匹配特征 I_cur(p_i)', 10, 42);
            photoCtx.fillStyle = '#ff6b6b';
            photoCtx.fillText('● 未匹配特征', 10, 54);
            
            // 显示实时数学指标
            const currentHistory = photometricHistory[photometricHistory.length - 1];
            if (currentHistory) {
                photoCtx.fillStyle = '#e0e0e0';
                photoCtx.font = '8px Arial';
                photoCtx.fillText(`E_photo: ${currentHistory.totalError.toFixed(2)}`, 10, 68);
                photoCtx.fillText(`平均误差: ${currentHistory.averageError.toFixed(3)}`, 10, 78);
                photoCtx.fillText(`匹配率: ${(currentHistory.matchedRatio * 100).toFixed(1)}%`, 10, 88);
            }
            
            // 绘制光度误差收敛面板（对应数学模型中的误差演化）
            errorCtx.clearRect(0, 0, photometricErrorCanvas.width, photometricErrorCanvas.height);
            
            // 调试信息
            console.log(`绘制收敛曲线: 历史数据点数 = ${photometricHistory.length}`);
            
            if (photometricHistory.length > 0) {
                // 绘制背景网格
                errorCtx.strokeStyle = '#333';
                errorCtx.lineWidth = 0.5;
                for (let i = 0; i < photometricErrorCanvas.width; i += 50) {
                    errorCtx.beginPath();
                    errorCtx.moveTo(i, 0);
                    errorCtx.lineTo(i, photometricErrorCanvas.height);
                    errorCtx.stroke();
                }
                for (let i = 0; i < photometricErrorCanvas.height; i += 30) {
                    errorCtx.beginPath();
                    errorCtx.moveTo(0, i);
                    errorCtx.lineTo(photometricErrorCanvas.width, i);
                    errorCtx.stroke();
                }
                
                // 绘制总光度误差曲线 E_photo = ∑_i ||r_i||^2
                errorCtx.strokeStyle = '#4ecdc4';
                errorCtx.lineWidth = 3;
                errorCtx.beginPath();
                
                const maxTotalError = Math.max(...photometricHistory.map(h => h.totalError), 1);
                const minTotalError = Math.min(...photometricHistory.map(h => h.totalError), 0);
                const errorRange = Math.max(maxTotalError - minTotalError, 0.1);
                
                for (let i = 0; i < photometricHistory.length; i++) {
                    const x = photometricHistory.length > 1 ? 
                        (i / (photometricHistory.length - 1)) * (photometricErrorCanvas.width - 40) + 20 :
                        photometricErrorCanvas.width / 2;
                    const normalizedError = (photometricHistory[i].totalError - minTotalError) / errorRange;
                    const y = photometricErrorCanvas.height - normalizedError * (photometricErrorCanvas.height * 0.3) - 50;
                    
                    if (i === 0) {
                        errorCtx.moveTo(x, y);
                    } else {
                        errorCtx.lineTo(x, y);
                    }
                    
                    // 绘制数据点
                    errorCtx.fillStyle = '#4ecdc4';
                    errorCtx.beginPath();
                    errorCtx.arc(x, y, 3, 0, 2 * Math.PI);
                    errorCtx.fill();
                }
                errorCtx.stroke();
                
                // 绘制平均误差曲线
                errorCtx.strokeStyle = '#ff8a8a';
                errorCtx.lineWidth = 2;
                errorCtx.beginPath();
                
                const maxAvgError = Math.max(...photometricHistory.map(h => h.averageError), 0.1);
                const minAvgError = Math.min(...photometricHistory.map(h => h.averageError), 0);
                const avgErrorRange = Math.max(maxAvgError - minAvgError, 0.01);
                
                for (let i = 0; i < photometricHistory.length; i++) {
                    const x = photometricHistory.length > 1 ? 
                        (i / (photometricHistory.length - 1)) * (photometricErrorCanvas.width - 40) + 20 :
                        photometricErrorCanvas.width / 2;
                    const normalizedAvgError = (photometricHistory[i].averageError - minAvgError) / avgErrorRange;
                    const y = photometricErrorCanvas.height - normalizedAvgError * (photometricErrorCanvas.height * 0.25) - 150;
                    
                    if (i === 0) {
                        errorCtx.moveTo(x, y);
                    } else {
                        errorCtx.lineTo(x, y);
                    }
                    
                    // 绘制数据点
                    errorCtx.fillStyle = '#ff8a8a';
                    errorCtx.beginPath();
                    errorCtx.arc(x, y, 2, 0, 2 * Math.PI);
                    errorCtx.fill();
                }
                errorCtx.stroke();
                
                // 绘制匹配率曲线
                errorCtx.strokeStyle = '#96ceb4';
                errorCtx.lineWidth = 2;
                errorCtx.beginPath();
                
                for (let i = 0; i < photometricHistory.length; i++) {
                    const x = photometricHistory.length > 1 ? 
                        (i / (photometricHistory.length - 1)) * (photometricErrorCanvas.width - 40) + 20 :
                        photometricErrorCanvas.width / 2;
                    const y = photometricErrorCanvas.height - photometricHistory[i].matchedRatio * (photometricErrorCanvas.height * 0.2) - 200;
                    
                    if (i === 0) {
                        errorCtx.moveTo(x, y);
                    } else {
                        errorCtx.lineTo(x, y);
                    }
                    
                    // 绘制数据点
                    errorCtx.fillStyle = '#96ceb4';
                    errorCtx.beginPath();
                    errorCtx.arc(x, y, 2, 0, 2 * Math.PI);
                    errorCtx.fill();
                }
                errorCtx.stroke();
                
                // 绘制曲线图例和数学含义
                errorCtx.fillStyle = '#ffffff';
                errorCtx.font = '12px Arial';
                errorCtx.fillText('光度误差收敛分析', 10, 20);
                
                // 绘制图例
                const legendY = 35;
                errorCtx.font = '10px Arial';
                
                // 总误差图例
                errorCtx.strokeStyle = '#4ecdc4';
                errorCtx.lineWidth = 3;
                errorCtx.beginPath();
                errorCtx.moveTo(10, legendY);
                errorCtx.lineTo(30, legendY);
                errorCtx.stroke();
                errorCtx.fillStyle = '#4ecdc4';
                errorCtx.beginPath();
                errorCtx.arc(20, legendY, 3, 0, 2 * Math.PI);
                errorCtx.fill();
                errorCtx.fillStyle = '#ffffff';
                errorCtx.fillText('E_photo (总误差)', 35, legendY + 4);
                
                // 平均误差图例
                errorCtx.strokeStyle = '#ff8a8a';
                errorCtx.lineWidth = 2;
                errorCtx.beginPath();
                errorCtx.moveTo(10, legendY + 15);
                errorCtx.lineTo(30, legendY + 15);
                errorCtx.stroke();
                errorCtx.fillStyle = '#ff8a8a';
                errorCtx.beginPath();
                errorCtx.arc(20, legendY + 15, 2, 0, 2 * Math.PI);
                errorCtx.fill();
                errorCtx.fillStyle = '#ffffff';
                errorCtx.fillText('平均误差', 35, legendY + 19);
                
                // 匹配率图例
                errorCtx.strokeStyle = '#96ceb4';
                errorCtx.lineWidth = 2;
                errorCtx.beginPath();
                errorCtx.moveTo(10, legendY + 30);
                errorCtx.lineTo(30, legendY + 30);
                errorCtx.stroke();
                errorCtx.fillStyle = '#96ceb4';
                errorCtx.beginPath();
                errorCtx.arc(20, legendY + 30, 2, 0, 2 * Math.PI);
                errorCtx.fill();
                errorCtx.fillStyle = '#ffffff';
                errorCtx.fillText('匹配率', 35, legendY + 34);
                
                // 显示实时数值
                if (photometricHistory.length > 0) {
                    const latest = photometricHistory[photometricHistory.length - 1];
                    errorCtx.fillStyle = '#ffffff';
                    errorCtx.font = '10px Arial';
                    const infoY = 100;
                    errorCtx.fillText(`迭代: ${currentPhotoIteration}/30`, 10, infoY);
                    errorCtx.fillText(`E_photo: ${latest.totalError.toFixed(2)}`, 10, infoY + 15);
                    errorCtx.fillText(`平均误差: ${latest.averageError.toFixed(3)}`, 10, infoY + 30);
                    errorCtx.fillText(`匹配率: ${(latest.matchedRatio * 100).toFixed(1)}%`, 10, infoY + 45);
                }
                
                // 数学模型说明
                errorCtx.fillStyle = '#cccccc';
                errorCtx.font = '8px Arial';
                const descY = photometricErrorCanvas.height - 40;
                errorCtx.fillText('数学模型: E_photo = ∑_i w_i ||I_cur(p_i) - I_ref(π(T*P_i))||^2', 10, descY);
                errorCtx.fillText('优化目标: 最小化光度误差，最大化特征点匹配率', 10, descY + 10);
                errorCtx.fillText('收敛条件: E_photo < ε 或 迭代次数达到上限', 10, descY + 20);
            }
            
            // 绘制参数影响分析（新增）
            drawPhotometricParameterAnalysis();
        }

        function resetPhotometricSimulation() {
            photometricRunning = false;
            currentPhotoIteration = 0;
            photometricHistory = [];
            imageFeatures = [];
            if (photoCtx) photoCtx.clearRect(0, 0, photometricCanvas.width, photometricCanvas.height);
            if (errorCtx) errorCtx.clearRect(0, 0, photometricErrorCanvas.width, photometricErrorCanvas.height);
        }

        // R3LIVE光度误差仿真参数影响分析函数（HTML格式）
        function drawPhotometricParameterAnalysis() {
            // 创建参数影响分析面板（如果不存在）
            let paramDiv = document.getElementById('photometricParamDiv');
            if (!paramDiv) {
                // 动态创建参数影响分析面板
                const parentDiv = document.querySelector('#photometricErrorCanvas').parentElement.parentElement;
                const newDiv = document.createElement('div');
                
                // 获取当前参数值用于动态显示（与数学模型严格对应）
                const N_i = parseInt(document.getElementById('frameCount').value) || 5;
                const pixelSetSize = parseInt(document.getElementById('pixelSetSize').value) || 200;
                const sigma_I_ref = parseFloat(document.getElementById('refImageNoise').value) || 1.0;
                const deltaT = parseFloat(document.getElementById('transformPerturbation').value) || 0.1;
                const alpha = parseFloat(document.getElementById('optStepSize').value) || 0.1;
                
                // 计算参数影响指标（与数学模型严格对应）
                const computational_complexity = Math.min(((N_i / 10) * 0.3 + (pixelSetSize / 500) * 0.5 + (alpha / 0.5) * 0.2) * 100, 100);
                const convergence_speed = Math.min(((alpha / 0.5) * 0.6 + (1 / (sigma_I_ref + 0.1)) * 0.2 + (1 / (deltaT + 0.01)) * 0.2) * 100, 100);
                const matching_accuracy = Math.min(((pixelSetSize / 500) * 0.4 + (1 / (sigma_I_ref + 0.1)) * 0.4 + (N_i / 10) * 0.2) * 100, 100);
                const robustness = Math.min(((sigma_I_ref / 5) * 0.3 + (deltaT / 0.5) * 0.3 + (pixelSetSize / 500) * 0.4) * 100, 100);
                const photometric_consistency = Math.min(((1 / (alpha + 0.01)) * 0.4 + (1 / (sigma_I_ref + 0.1)) * 0.4 + (N_i / 10) * 0.2) * 100, 100);
                
                newDiv.innerHTML = `
                    <div id="photometricParamDiv" style="margin-top: 20px;">
                        <!-- 参数影响分析 -->
                        <div class="math-formula" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                            <h4 style="color: #4ecdc4; margin-bottom: 15px;">📈 R3LIVE光度误差参数影响分析</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 13px; color: #e0e0e0;">
                                <div>
                                    <h5 style="color: #ff6b6b; margin-bottom: 10px;">计算性能指标：</h5>
                                    <div style="margin-bottom: 15px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                            <span style="color: #ff8a8a; font-weight: bold;">计算复杂度</span>
                                            <span style="color: #ffffff;">${computational_complexity.toFixed(1)}%</span>
                                        </div>
                                        <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                                            <div style="width: ${computational_complexity}%; height: 100%; background: #ff6b6b; transition: width 0.3s ease;"></div>
                                        </div>
                                        <div style="font-size: 11px; color: #cccccc; margin-top: 3px;">受N<sub>i</sub>、|Ω<sub>i</sub>|和α影响，帧数和像素数越多计算量越大</div>
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                            <span style="color: #4ecdc4; font-weight: bold;">收敛速度</span>
                                            <span style="color: #ffffff;">${convergence_speed.toFixed(1)}%</span>
                                        </div>
                                        <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                                            <div style="width: ${convergence_speed}%; height: 100%; background: #4ecdc4; transition: width 0.3s ease;"></div>
                                        </div>
                                        <div style="font-size: 11px; color: #cccccc; margin-top: 3px;">主要受优化步长α影响，步长越大收敛越快</div>
                                    </div>
                                    <div>
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                            <span style="color: #45b7d1; font-weight: bold;">匹配精度</span>
                                            <span style="color: #ffffff;">${matching_accuracy.toFixed(1)}%</span>
                                        </div>
                                        <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                                            <div style="width: ${matching_accuracy}%; height: 100%; background: #45b7d1; transition: width 0.3s ease;"></div>
                                        </div>
                                        <div style="font-size: 11px; color: #cccccc; margin-top: 3px;">受N<sub>p</sub>和σ<sub>I</sub>影响，特征点多噪声小精度高</div>
                                    </div>
                                </div>
                                <div>
                                    <h5 style="color: #ffaa00; margin-bottom: 10px;">系统鲁棒性指标：</h5>
                                    <div style="margin-bottom: 15px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                            <span style="color: #96ceb4; font-weight: bold;">鲁棒性</span>
                                            <span style="color: #ffffff;">${robustness.toFixed(1)}%</span>
                                        </div>
                                        <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                                            <div style="width: ${robustness}%; height: 100%; background: #96ceb4; transition: width 0.3s ease;"></div>
                                        </div>
                                        <div style="font-size: 11px; color: #cccccc; margin-top: 3px;">受σ<sub>I</sub>和特征密度影响，适度噪声提高鲁棒性</div>
                                    </div>
                                    <div>
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                            <span style="color: #feca57; font-weight: bold;">光度一致性</span>
                                            <span style="color: #ffffff;">${photometric_consistency.toFixed(1)}%</span>
                                        </div>
                                        <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                                            <div style="width: ${photometric_consistency}%; height: 100%; background: #feca57; transition: width 0.3s ease;"></div>
                                        </div>
                                        <div style="font-size: 11px; color: #cccccc; margin-top: 3px;">受α和σ<sub>I</sub>影响，反映优化效果质量</div>
                                    </div>
                                </div>
                            </div>
                            <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                                <h5 style="color: #4ecdc4; margin-bottom: 8px;">📊 当前参数状态：</h5>
                                <div style="display: flex; justify-content: space-between; font-size: 12px; color: #e0e0e0;">
                                    <span>|Ω<sub>i</sub>|: <strong style="color: #ff6b6b;">${pixelSetSize}</strong></span>
                                    <span>σ<sub>I_ref</sub>: <strong style="color: #45b7d1;">${sigma_I_ref}</strong></span>
                                    <span>α: <strong style="color: #96ceb4;">${alpha}</strong></span>
                                    <span style="font-size: 10px; color: #cccccc;">E<sub>photo</sub> = Σ<sub>i</sub> w<sub>i</sub> ||I<sub>cur</sub>(p<sub>i</sub>) - I<sub>ref</sub>(π(T*P<sub>i</sub>))||²</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                parentDiv.appendChild(newDiv);
                paramDiv = document.getElementById('photometricParamDiv');
            }
            
            // HTML格式不需要重绘，只需要创建一次
            // 可以在这里添加实时更新逻辑（如果需要）
            
            // 获取当前参数值（与数学模型严格对应）
            const N_i = parseInt(document.getElementById('frameCount').value) || 5;
            const pixelSetSize = parseInt(document.getElementById('pixelSetSize').value) || 200;  // |Ω_i|
            const sigma_I_ref = parseFloat(document.getElementById('refImageNoise').value) || 1.0;
            const deltaT = parseFloat(document.getElementById('transformPerturbation').value) || 0.1;
            const alpha = parseFloat(document.getElementById('optStepSize').value) || 0.1;
            
            // 计算参数影响指标（对应数学模型中的性能指标）
            const parameterImpacts = {
                // 计算复杂度 = f(|Ω_i|, α) - 像素集合大小和优化步长的影响
                computational_complexity: (pixelSetSize / 200) * 0.6 + (alpha / 0.5) * 0.4,
                
                // 收敛速度 = f(α, σ_{I_ref}) - 优化步长和噪声水平的影响
                convergence_speed: (alpha / 0.5) * 0.7 + (1 / (sigma_I_ref + 1)) * 0.3,
                
                // 匹配精度 = f(|Ω_i|, σ_{I_ref}) - 像素集合大小和噪声的影响
                matching_accuracy: (pixelSetSize / 500) * 0.5 + (1 / (sigma_I_ref + 1)) * 0.5,
                
                // 鲁棒性 = f(σ_{I_ref}, |Ω_i|) - 噪声容忍度和像素密度
                robustness: (sigma_I_ref / 20) * 0.4 + (pixelSetSize / 500) * 0.6,
                
                // 光度一致性 = f(α, σ_{I_ref}) - 优化效果和噪声影响
                photometric_consistency: (1 / (alpha + 0.1)) * 0.4 + (1 / (sigma_I_ref + 1)) * 0.6
            };
            
            // 绘制参数影响条形图
            const barHeight = 25;
            const barSpacing = 35;
            const startY = 40;
            const maxBarWidth = paramCanvas.width - 200;
            
            const impacts = [
                { name: '计算复杂度', value: parameterImpacts.computational_complexity, color: '#ff6b6b', unit: '', desc: '受像素集合|Ω_i|和优化步长α影响' },
                { name: '收敛速度', value: parameterImpacts.convergence_speed, color: '#4ecdc4', unit: '', desc: '主要受优化步长α影响' },
                { name: '匹配精度', value: parameterImpacts.matching_accuracy, color: '#45b7d1', unit: '', desc: '受像素集合|Ω_i|和噪声σ_{I_ref}影响' },
                { name: '鲁棒性', value: parameterImpacts.robustness, color: '#96ceb4', unit: '', desc: '受噪声σ_{I_ref}和像素密度影响' },
                { name: '光度一致性', value: parameterImpacts.photometric_consistency, color: '#feca57', unit: '', desc: '受优化步长α和噪声σ_{I_ref}影响' }
            ];
            
            // 绘制面板标题
            paramCtx.fillStyle = '#ffffff';
            paramCtx.font = 'bold 14px Arial';
            paramCtx.fillText('R3LIVE光度误差参数影响分析', 10, 20);
            
            impacts.forEach((impact, index) => {
                const y = startY + index * barSpacing;
                const barWidth = Math.min(Math.max(impact.value * maxBarWidth, 10), maxBarWidth);
                
                // 绘制条形背景
                paramCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                paramCtx.fillRect(120, y, maxBarWidth, barHeight);
                
                // 绘制条形
                paramCtx.fillStyle = impact.color;
                paramCtx.fillRect(120, y, barWidth, barHeight);
                
                // 绘制条形边框
                paramCtx.strokeStyle = impact.color;
                paramCtx.lineWidth = 1;
                paramCtx.strokeRect(120, y, maxBarWidth, barHeight);
                
                // 绘制标签和数值
                paramCtx.fillStyle = '#ffffff';
                paramCtx.font = '11px Arial';
                paramCtx.fillText(impact.name, 10, y + 16);
                paramCtx.fillText(impact.value.toFixed(2), maxBarWidth + 130, y + 16);
                
                // 绘制百分比标记（放在条形内部）
                const percentage = Math.min(impact.value * 100, 100);
                if (barWidth > 40) {
                    paramCtx.fillStyle = '#000000';
                    paramCtx.font = 'bold 8px Arial';
                    paramCtx.fillText(`${percentage.toFixed(0)}%`, 125 + barWidth/2 - 10, y + 16);
                }
            });
            
            // 检查是否有足够空间显示说明文本
            const remainingHeight = paramCanvas.height - (startY + impacts.length * barSpacing + 10);
            
            if (remainingHeight > 120) {
                // 绘制详细的参数影响说明
                const descStartY = startY + impacts.length * barSpacing + 20;
                paramCtx.fillStyle = '#cccccc';
                paramCtx.font = '10px Arial';
                paramCtx.fillText('参数影响机制：', 10, descStartY);
                
                const descriptions = [
                    '• 像素集合大小|Ω_i|调节影响：',
                    '  ↑增大: 提高匹配精度和鲁棒性，增强光度一致性，但计算复杂度上升',
                    '  ↓减小: 降低计算负担，但匹配精度下降，易受噪声干扰',
                    '• 参考帧噪声σ_{I_ref}调节影响：',
                    '  ↑增大: 模拟真实环境噪声，测试鲁棒性，但匹配精度显著下降',
                    '  ↓减小: 提高匹配精度和光度一致性，但过于理想化',
                    '• 优化步长α调节影响：',
                    '  ↑增大: 加快收敛速度，减少迭代次数，但可能导致震荡不稳定',
                    '  ↓减小: 收敛更稳定平滑，但需要更多迭代，计算时间增加'
                ];
                
                descriptions.forEach((desc, index) => {
                    paramCtx.fillText(desc, 10, descStartY + 15 + index * 12);
                });
                
                // 绘制参数调节建议
                const adviceStartY = descStartY + descriptions.length * 12 + 25;
                paramCtx.fillStyle = '#96ceb4';
                paramCtx.font = 'bold 10px Arial';
                paramCtx.fillText('参数调节建议：', 10, adviceStartY);
                
                paramCtx.fillStyle = '#e0e0e0';
                paramCtx.font = '9px Arial';
                const advice = [
                    '• 高精度模式：|Ω_i|=300-500, σ_{I_ref}=1-3, α=0.1-0.3 (实验室环境)',
                    '• 高效率模式：|Ω_i|=100-200, σ_{I_ref}=3-8, α=0.3-0.7 (实时应用)',
                    '• 高鲁棒性模式：|Ω_i|=200-400, σ_{I_ref}=5-15, α=0.05-0.2 (恶劣环境)',
                    '• 调试模式：先固定两个参数，逐个调节第三个参数观察效果',
                    '• 收敛判断：当E_photo变化<1%且匹配率>80%时达到最优'
                ];
                
                advice.forEach((adv, index) => {
                    paramCtx.fillText(adv, 10, adviceStartY + 15 + index * 12);
                });
            } else {
                // 空间不足时只显示最基本信息
                const infoY = startY + impacts.length * barSpacing + 10;
                paramCtx.fillStyle = '#cccccc';
                paramCtx.font = '8px Arial';
                paramCtx.fillText('调节参数观察性能变化 | 高精度:↑|Ω_i| ↓σ_{I_ref} | 高效率:↑α | 高鲁棒性:↑|Ω_i|', 10, infoY);
            }
            
            // 绘制当前参数状态
            const currentParams = [
                `|Ω_i|: ${pixelSetSize}`,
                `σ_{I_ref}: ${sigma_I_ref}`, 
                `α: ${alpha}`
            ];
            
            paramCtx.fillStyle = '#e0e0e0';
            paramCtx.font = '10px Arial';
            currentParams.forEach((param, index) => {
                const x = 10 + index * 80;
                const y = paramCanvas.height - 20;
                paramCtx.fillText(param, x, y);
            });
            
            // 绘制数学模型对应说明
            paramCtx.fillStyle = '#ffffff';
            paramCtx.font = '8px Arial';
            paramCtx.fillText('数学模型: E_photo = Σᵢ wᵢ ||I_cur(pᵢ) - I_ref(π(T*Pᵢ))||² → min', 10, paramCanvas.height - 5);
        }

        // R3LIVE光度误差仿真参数调节指南面板（HTML格式）
        function drawPhotometricParameterGuide() {
            // 创建参数调节指南面板（如果不存在）
            let guideDiv = document.getElementById('photometricGuideDiv');
            if (!guideDiv) {
                // 动态创建参数调节指南面板
                const parentDiv = document.querySelector('#photometricErrorCanvas').parentElement.parentElement;
                const newDiv = document.createElement('div');
                newDiv.innerHTML = `
                    <div id="photometricGuideDiv" style="margin-top: 20px;">
                        <!-- 参数调节指南 -->
                        <div class="math-formula" style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                            <h4 style="color: #4ecdc4; margin-bottom: 15px;">🎯 R3LIVE光度误差参数调节指南</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 13px; color: #e0e0e0;">
                                <div>
                                    <h5 style="color: #ff6b6b; margin-bottom: 10px;">特征点参数影响：</h5>
                                    <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                        <li><strong style="color: #ff8a8a;">增大 N<sub>p</sub></strong>：特征点数量增加 → 匹配精度和鲁棒性提高，但计算复杂度上升</li>
                                        <li><strong style="color: #ff8a8a;">减少 N<sub>p</sub></strong>：特征点数量减少 → 计算负担降低，但匹配精度下降，易受噪声干扰</li>
                                        <li><strong style="color: #ff8a8a;">增大 σ<sub>I</sub></strong>：图像噪声增大 → 模拟真实环境，测试系统鲁棒性，但匹配精度下降</li>
                                        <li><strong style="color: #ff8a8a;">减小 σ<sub>I</sub></strong>：图像噪声减小 → 匹配精度提高，光度一致性增强，但过于理想化</li>
                                    </ul>
                                </div>
                                <div>
                                    <h5 style="color: #ffaa00; margin-bottom: 10px;">优化参数影响：</h5>
                                    <ul style="margin: 0; padding-left: 20px; line-height: 1.6; color: #e0e0e0;">
                                        <li><strong style="color: #ffcc66;">增大 α</strong>：优化步长增大 → 收敛速度加快，迭代次数减少，但可能导致震荡不稳定</li>
                                        <li><strong style="color: #ffcc66;">减小 α</strong>：优化步长减小 → 收敛更稳定平滑，避免震荡发散，但需要更多迭代</li>
                                        <li><strong style="color: #ffcc66;">光度一致性</strong>：反映优化效果 E<sub>photo</sub> = Σ<sub>i</sub> w<sub>i</sub> ||I<sub>cur</sub>(p<sub>i</sub>) - I<sub>ref</sub>(π(T*P<sub>i</sub>))||²</li>
                                        <li><strong style="color: #ffcc66;">收敛判断</strong>：当E<sub>photo</sub>连续5次迭代变化<1%且匹配率>80%时达到最优</li>
                                    </ul>
                                </div>
                            </div>
                            <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                                <h5 style="color: #4ecdc4; margin-bottom: 8px;">📊 推荐配置策略：</h5>
                                <div style="display: flex; justify-content: space-between; font-size: 12px; color: #e0e0e0;">
                                    <span><strong style="color: #ff6b6b;">高精度模式</strong>：N<sub>p</sub>=300-500, σ<sub>I</sub>=1-3, α=0.1-0.3</span>
                                    <span><strong style="color: #4ecdc4;">高效率模式</strong>：N<sub>p</sub>=100-200, σ<sub>I</sub>=3-8, α=0.3-0.7</span>
                                    <span><strong style="color: #96ceb4;">高鲁棒性模式</strong>：N<sub>p</sub>=200-400, σ<sub>I</sub>=5-15, α=0.05-0.2</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                parentDiv.appendChild(newDiv);
                guideDiv = document.getElementById('photometricGuideDiv');
            }
            
            // HTML格式不需要重绘，只需要创建一次
        }

        // ESIKF仿真变量
        let esikfRunning = false;
        let esikfTrajectoryCanvas, esikfCovarianceCanvas, esikfVariableCanvas;
        let esikfTrajCtx, esikfCovCtx, esikfVarCtx;
        let esikfState = {
            position: [0, 0],
            velocity: [0, 0],
            orientation: 0,
            bias_acc: [0, 0],
            bias_gyro: 0
        };
        let esikfCovariance = {
            P: [[1, 0], [0, 1]], // 简化的2x2协方差矩阵
            trace: [],
            kalmanGain: [],
            innovation: []
        };
        let esikfTrajectory = [];
        let esikfTime = 0;
        let esikfIteration = 0;
        
        function initESIKFCanvas() {
            esikfTrajectoryCanvas = document.getElementById('esikfTrajectoryCanvas');
            esikfCovarianceCanvas = document.getElementById('esikfCovarianceCanvas');
            esikfVariableCanvas = document.getElementById('esikfVariableCanvas');
            
            if (esikfTrajectoryCanvas && esikfCovarianceCanvas && esikfVariableCanvas) {
                esikfTrajCtx = esikfTrajectoryCanvas.getContext('2d');
                esikfCovCtx = esikfCovarianceCanvas.getContext('2d');
                esikfVarCtx = esikfVariableCanvas.getContext('2d');
                
                esikfTrajectoryCanvas.width = esikfTrajectoryCanvas.offsetWidth;
                esikfTrajectoryCanvas.height = esikfTrajectoryCanvas.offsetHeight;
                esikfCovarianceCanvas.width = esikfCovarianceCanvas.offsetWidth;
                esikfCovarianceCanvas.height = esikfCovarianceCanvas.offsetHeight;
                esikfVariableCanvas.width = esikfVariableCanvas.offsetWidth;
                esikfVariableCanvas.height = esikfVariableCanvas.offsetHeight;
            }
        }
        
        function initESIKFSimulation() {
            initESIKFCanvas();
        }

        function startESIKFSimulation() {
            if (esikfRunning) return;
            
            // 初始化ESIKF仿真参数（与数学模型严格对应）
            initESIKFCanvas();
            esikfRunning = true;
            esikfTime = 0;
            esikfIteration = 0;
            
            // 获取仿真参数
            const f_IMU = parseInt(document.getElementById('esikfIMUFreq').value);  // IMU采样频率
            const f_cam = parseInt(document.getElementById('esikfCamFreq').value);  // 相机观测频率
            const sigma_Q = parseFloat(document.getElementById('esikfProcessNoise').value);  // 过程噪声
            const sigma_R = parseFloat(document.getElementById('esikfObsNoise').value);  // 观测噪声
            const P_0 = parseFloat(document.getElementById('esikfInitCov').value);  // 初始协方差
            const N_iter = parseInt(document.getElementById('esikfIterations').value);  // ESIKF迭代次数
            
            // 初始化状态向量 X = [p_x, p_y, v_x, v_y, θ, b_a, b_g]^T
            esikfState = {
                // 名义状态 X_nom
                position: [esikfTrajectoryCanvas.width / 2, esikfTrajectoryCanvas.height / 2],  // 位置 p
                velocity: [30, 20],  // 速度 v（增大初始速度使运动明显）
                orientation: 0,    // 姿态角 θ
                bias_acc: [0.1, 0.1],  // 加速度计偏置 b_a（添加小偏置模拟真实情况）
                bias_gyro: 0.05       // 陀螺仪偏置 b_g（添加小偏置模拟真实情况）
            };
            
            // 初始化误差状态协方差矩阵 P_0
            esikfCovariance = {
                P: [
                    [P_0, 0, 0, 0, 0, 0, 0],
                    [0, P_0, 0, 0, 0, 0, 0],
                    [0, 0, P_0, 0, 0, 0, 0],
                    [0, 0, 0, P_0, 0, 0, 0],
                    [0, 0, 0, 0, P_0, 0, 0],
                    [0, 0, 0, 0, 0, P_0, 0],
                    [0, 0, 0, 0, 0, 0, P_0]
                ],
                trace: [],
                kalmanGain: [],
                innovation: []
            };
            
            esikfTrajectory = [{
                x: esikfState.position[0],
                y: esikfState.position[1],
                time: esikfTime
            }];
            
            runESIKFStep();
        }

        function runESIKFStep() {
            if (!esikfRunning) return;
            
            // 获取ESIKF仿真参数（与数学模型严格对应）
            const f_IMU = parseInt(document.getElementById('esikfIMUFreq').value);  // IMU采样频率
            const f_cam = parseInt(document.getElementById('esikfCamFreq').value);  // 相机观测频率
            const sigma_Q = parseFloat(document.getElementById('esikfProcessNoise').value);  // 过程噪声标准差
            const sigma_R = parseFloat(document.getElementById('esikfObsNoise').value);  // 观测噪声标准差
            const N_iter = parseInt(document.getElementById('esikfIterations').value);  // ESIKF迭代次数
            
            const dt = 1.0 / f_IMU;  // IMU采样时间间隔
            esikfTime += dt;
            esikfIteration++;
            
            // ESIKF预测步骤（对应数学模型中的预测方程）
            predictESIKFState(dt, sigma_Q);
            
            // 每隔一定时间进行相机观测更新（对应数学模型中的更新方程）
            // 为了更好地显示卡尔曼增益曲线，增加相机更新频率
            const camUpdateInterval = Math.max(Math.floor(f_IMU / f_cam), 2); // 最小间隔为2
            if (esikfIteration % camUpdateInterval === 0) {
                updateESIKFWithCamera(sigma_R, N_iter);
            }
            
            // 记录状态估计轨迹（对应数学模型中的X_k）
            esikfTrajectory.push({
                x: esikfState.position[0],
                y: esikfState.position[1],
                time: esikfTime
            });
            
            // 记录协方差矩阵迹（对应数学模型中的tr(P_k)）
            let trace = 0;
            for (let i = 0; i < esikfCovariance.P.length; i++) {
                trace += esikfCovariance.P[i][i];
            }
            esikfCovariance.trace.push(trace);
            
            drawESIKFVisualization();
            
            // 限制仿真时间
            if (esikfTime < 10.0) {
                setTimeout(() => runESIKFStep(), 50);
            } else {
                esikfRunning = false;
            }
        }

        function predictESIKFState(dt, sigma_Q) {
            // ESIKF预测步骤（对应数学模型中的状态传播方程）
            
            // 模拟IMU测量值（包含噪声和偏置），增大运动幅度使轨迹可见
            const a_m = [  // 加速度计测量 a_m = a_true + b_a + n_a
                20 * Math.sin(esikfTime * 0.5) + esikfState.bias_acc[0] + (Math.random() - 0.5) * sigma_Q,
                15 * Math.cos(esikfTime * 0.3) + esikfState.bias_acc[1] + (Math.random() - 0.5) * sigma_Q
            ];
            const omega_m = 0.3 * Math.sin(esikfTime * 0.2) + esikfState.bias_gyro + (Math.random() - 0.5) * sigma_Q;  // 陀螺仪测量
            
            // 名义状态传播（对应数学模型中的 X_nom(k+1) = f(X_nom(k), u_k)）
            // 位置更新：p_{k+1} = p_k + v_k * dt + 0.5 * a_k * dt^2
            esikfState.position[0] += esikfState.velocity[0] * dt + 0.5 * (a_m[0] - esikfState.bias_acc[0]) * dt * dt;
            esikfState.position[1] += esikfState.velocity[1] * dt + 0.5 * (a_m[1] - esikfState.bias_acc[1]) * dt * dt;
            
            // 速度更新：v_{k+1} = v_k + a_k * dt
            esikfState.velocity[0] += (a_m[0] - esikfState.bias_acc[0]) * dt;
            esikfState.velocity[1] += (a_m[1] - esikfState.bias_acc[1]) * dt;
            
            // 姿态更新：θ_{k+1} = θ_k + ω_k * dt
            esikfState.orientation += (omega_m - esikfState.bias_gyro) * dt;
            
            // 偏置随机游走模型：b_{k+1} = b_k + w_b
            esikfState.bias_acc[0] += (Math.random() - 0.5) * sigma_Q * 0.1 * dt;
            esikfState.bias_acc[1] += (Math.random() - 0.5) * sigma_Q * 0.1 * dt;
            esikfState.bias_gyro += (Math.random() - 0.5) * sigma_Q * 0.1 * dt;
            
            // 边界检查
            if (esikfState.position[0] < 50) esikfState.position[0] = 50;
            if (esikfState.position[0] > esikfTrajectoryCanvas.width - 50) esikfState.position[0] = esikfTrajectoryCanvas.width - 50;
            if (esikfState.position[1] < 50) esikfState.position[1] = 50;
            if (esikfState.position[1] > esikfTrajectoryCanvas.height - 50) esikfState.position[1] = esikfTrajectoryCanvas.height - 50;
            
            // 计算状态转移矩阵 F_k = ∂f/∂δx（对应数学模型中的雅可比矩阵）
            const F_k = [
                [1, 0, dt, 0, 0, 0, 0],     // ∂p_x/∂[δp_x, δp_y, δv_x, δv_y, δθ, δb_a, δb_g]
                [0, 1, 0, dt, 0, 0, 0],     // ∂p_y/∂[δp_x, δp_y, δv_x, δv_y, δθ, δb_a, δb_g]
                [0, 0, 1, 0, 0, -dt, 0],    // ∂v_x/∂[δp_x, δp_y, δv_x, δv_y, δθ, δb_a, δb_g]
                [0, 0, 0, 1, 0, 0, -dt],    // ∂v_y/∂[δp_x, δp_y, δv_x, δv_y, δθ, δb_a, δb_g]
                [0, 0, 0, 0, 1, 0, 0],      // ∂θ/∂[δp_x, δp_y, δv_x, δv_y, δθ, δb_a, δb_g]
                [0, 0, 0, 0, 0, 1, 0],      // ∂b_a/∂[δp_x, δp_y, δv_x, δv_y, δθ, δb_a, δb_g]
                [0, 0, 0, 0, 0, 0, 1]       // ∂b_g/∂[δp_x, δp_y, δv_x, δv_y, δθ, δb_a, δb_g]
            ];
            
            // 过程噪声协方差矩阵 Q_k（对应数学模型中的过程噪声）
            const Q_k = [
                [sigma_Q * sigma_Q * dt * dt, 0, 0, 0, 0, 0, 0],
                [0, sigma_Q * sigma_Q * dt * dt, 0, 0, 0, 0, 0],
                [0, 0, sigma_Q * sigma_Q * dt, 0, 0, 0, 0],
                [0, 0, 0, sigma_Q * sigma_Q * dt, 0, 0, 0],
                [0, 0, 0, 0, sigma_Q * sigma_Q * dt, 0, 0],
                [0, 0, 0, 0, 0, sigma_Q * sigma_Q * 0.01 * dt, 0],
                [0, 0, 0, 0, 0, 0, sigma_Q * sigma_Q * 0.01 * dt]
            ];
            
            // 协方差传播：P_{k+1|k} = F_k * P_{k|k} * F_k^T + Q_k（对应数学模型中的协方差预测）
            const P_new = matrixMultiply(matrixMultiply(F_k, esikfCovariance.P), matrixTranspose(F_k));
            esikfCovariance.P = matrixAdd(P_new, Q_k);
        }

        function updateESIKFWithCamera(sigma_R, N_iter) {
            // ESIKF相机观测更新步骤（对应数学模型中的迭代更新方程）
            
            // 模拟相机观测值 z_k = h(X_k) + v_k（包含观测噪声）
            const z_obs = [  // 相机观测的位置信息
                esikfState.position[0] + (Math.random() - 0.5) * sigma_R * 10,  // 观测位置 x
                esikfState.position[1] + (Math.random() - 0.5) * sigma_R * 10   // 观测位置 y
            ];
            
            // 观测噪声协方差矩阵 R_k（对应数学模型中的观测噪声）
            const R_k = [
                [sigma_R * sigma_R * 100, 0],
                [0, sigma_R * sigma_R * 100]
            ];
            
            // ESIKF迭代更新（对应数学模型中的迭代求解）
            for (let iter = 0; iter < N_iter; iter++) {
                // 计算观测雅可比矩阵 H_k = ∂h/∂δx（对应数学模型中的观测雅可比）
                const H_k = [
                    [1, 0, 0, 0, 0, 0, 0],  // ∂h_x/∂[δp_x, δp_y, δv_x, δv_y, δθ, δb_a, δb_g]
                    [0, 1, 0, 0, 0, 0, 0]   // ∂h_y/∂[δp_x, δp_y, δv_x, δv_y, δθ, δb_a, δb_g]
                ];
                
                // 计算创新协方差矩阵 S_k = H_k * P_{k|k-1} * H_k^T + R_k
                const P_H_T = matrixMultiply(esikfCovariance.P, matrixTranspose(H_k));
                const H_P_H_T = matrixMultiply(H_k, P_H_T);
                const S_k = matrixAdd(H_P_H_T, R_k);
                
                // 计算卡尔曼增益矩阵 K_k = P_{k|k-1} * H_k^T * S_k^{-1}（对应数学模型中的卡尔曼增益）
                const S_inv = matrixInverse2x2(S_k);
                const K_k = matrixMultiply(P_H_T, S_inv);
                
                // 计算创新向量 ν_k = z_k - h(X_nom)（对应数学模型中的观测创新）
                const h_pred = [esikfState.position[0], esikfState.position[1]];  // 预测观测值
                const nu_k = [z_obs[0] - h_pred[0], z_obs[1] - h_pred[1]];  // 创新向量
                
                // 状态更新：δx_k = K_k * ν_k（对应数学模型中的误差状态更新）
                const delta_x = matrixVectorMultiply(K_k, nu_k);
                
                // 名义状态更新：X_nom = X_nom ⊕ δx（对应数学模型中的状态更新）
                esikfState.position[0] += delta_x[0];
                esikfState.position[1] += delta_x[1];
                esikfState.velocity[0] += delta_x[2];
                esikfState.velocity[1] += delta_x[3];
                esikfState.orientation += delta_x[4];
                esikfState.bias_acc[0] += delta_x[5];
                esikfState.bias_gyro += delta_x[6];
                
                // 协方差更新：P_{k|k} = (I - K_k * H_k) * P_{k|k-1}（对应数学模型中的协方差更新）
                const I = matrixIdentity(7);
                const K_H = matrixMultiply(K_k, H_k);
                const I_minus_KH = matrixSubtract(I, K_H);
                esikfCovariance.P = matrixMultiply(I_minus_KH, esikfCovariance.P);
                
                // 记录卡尔曼增益和创新向量（用于可视化）
                esikfCovariance.kalmanGain.push({
                    K: K_k,
                    iteration: iter,
                    time: esikfTime
                });
                esikfCovariance.innovation.push({
                    nu: nu_k,
                    iteration: iter,
                    time: esikfTime
                });
            }
            
            // 确保协方差矩阵的数值稳定性
            for (let i = 0; i < esikfCovariance.P.length; i++) {
                for (let j = 0; j < esikfCovariance.P[i].length; j++) {
                    if (i === j) {
                        esikfCovariance.P[i][j] = Math.max(esikfCovariance.P[i][j], 0.001);
                    }
                }
            }
        }

        function drawESIKFVisualization() {
            if (!esikfTrajCtx || !esikfCovCtx || !esikfVarCtx) return;
            
            // 绘制状态估计轨迹面板
            esikfTrajCtx.clearRect(0, 0, esikfTrajectoryCanvas.width, esikfTrajectoryCanvas.height);
            
            // 绘制背景网格
            esikfTrajCtx.strokeStyle = '#333';
            esikfTrajCtx.lineWidth = 0.5;
            for (let i = 0; i < esikfTrajectoryCanvas.width; i += 30) {
                esikfTrajCtx.beginPath();
                esikfTrajCtx.moveTo(i, 0);
                esikfTrajCtx.lineTo(i, esikfTrajectoryCanvas.height);
                esikfTrajCtx.stroke();
            }
            for (let i = 0; i < esikfTrajectoryCanvas.height; i += 30) {
                esikfTrajCtx.beginPath();
                esikfTrajCtx.moveTo(0, i);
                esikfTrajCtx.lineTo(esikfTrajectoryCanvas.width, i);
                esikfTrajCtx.stroke();
            }
            
            // 绘制轨迹线（对应数学模型中的X_k）
            if (esikfTrajectory.length > 1) {
                esikfTrajCtx.strokeStyle = '#4ecdc4';
                esikfTrajCtx.lineWidth = 2;
                esikfTrajCtx.beginPath();
                esikfTrajCtx.moveTo(esikfTrajectory[0].x, esikfTrajectory[0].y);
                for (let i = 1; i < esikfTrajectory.length; i++) {
                    esikfTrajCtx.lineTo(esikfTrajectory[i].x, esikfTrajectory[i].y);
                }
                esikfTrajCtx.stroke();
            }
            
            // 绘制当前位置（对应数学模型中的p_k）
            esikfTrajCtx.fillStyle = '#ff6b6b';
            esikfTrajCtx.beginPath();
            esikfTrajCtx.arc(esikfState.position[0], esikfState.position[1], 8, 0, 2 * Math.PI);
            esikfTrajCtx.fill();
            
            // 绘制不确定性椭圆（对应数学模型中的P_k）
            esikfTrajCtx.strokeStyle = '#ff6b6b';
            esikfTrajCtx.lineWidth = 2;
            esikfTrajCtx.setLineDash([5, 5]);
            esikfTrajCtx.beginPath();
            const ellipseSize = Math.sqrt(esikfCovariance.P[0][0]) * 20;
            esikfTrajCtx.ellipse(esikfState.position[0], esikfState.position[1], ellipseSize, ellipseSize, 0, 0, 2 * Math.PI);
            esikfTrajCtx.stroke();
            esikfTrajCtx.setLineDash([]);
            
            // 绘制方向箭头（对应数学模型中的θ_k）
            const arrowLength = 20;
            const arrowX = esikfState.position[0] + Math.cos(esikfState.orientation) * arrowLength;
            const arrowY = esikfState.position[1] + Math.sin(esikfState.orientation) * arrowLength;
            esikfTrajCtx.strokeStyle = '#45b7d1';
            esikfTrajCtx.lineWidth = 3;
            esikfTrajCtx.beginPath();
            esikfTrajCtx.moveTo(esikfState.position[0], esikfState.position[1]);
            esikfTrajCtx.lineTo(arrowX, arrowY);
            esikfTrajCtx.stroke();
            
            // 绘制状态信息显示
            esikfTrajCtx.fillStyle = '#ffffff';
            esikfTrajCtx.font = '12px Arial';
            esikfTrajCtx.fillText(`时间 t: ${esikfTime.toFixed(2)}s`, 10, 20);
            esikfTrajCtx.fillText(`位置 p: (${esikfState.position[0].toFixed(1)}, ${esikfState.position[1].toFixed(1)})`, 10, 35);
            esikfTrajCtx.fillText(`姿态 θ: ${(esikfState.orientation * 180 / Math.PI).toFixed(1)}°`, 10, 50);
            if (esikfTrajectory.length > 1) {
                esikfTrajCtx.fillText(`速度 v: (${esikfState.velocity[0].toFixed(2)}, ${esikfState.velocity[1].toFixed(2)})`, 10, 65);
                esikfTrajCtx.fillText(`偏置 b_a: (${esikfState.bias_acc[0].toFixed(3)}, ${esikfState.bias_acc[1].toFixed(3)})`, 10, 80);
                esikfTrajCtx.fillText(`偏置 b_g: ${esikfState.bias_gyro.toFixed(3)}`, 10, 95);
            }
            
            // 绘制协方差演化面板
            esikfCovCtx.clearRect(0, 0, esikfCovarianceCanvas.width, esikfCovarianceCanvas.height);
            
            // 绘制背景网格和坐标轴
            esikfCovCtx.strokeStyle = '#333';
            esikfCovCtx.lineWidth = 0.5;
            for (let i = 0; i < esikfCovarianceCanvas.width; i += 50) {
                esikfCovCtx.beginPath();
                esikfCovCtx.moveTo(i, 0);
                esikfCovCtx.lineTo(i, esikfCovarianceCanvas.height);
                esikfCovCtx.stroke();
            }
            for (let i = 0; i < esikfCovarianceCanvas.height; i += 30) {
                esikfCovCtx.beginPath();
                esikfCovCtx.moveTo(0, i);
                esikfCovCtx.lineTo(esikfCovarianceCanvas.width, i);
                esikfCovCtx.stroke();
            }
            
            if (esikfCovariance.trace.length > 1) {
                // 绘制协方差迹曲线（对应数学模型中的tr(P_k)）
                esikfCovCtx.strokeStyle = '#4ecdc4';
                esikfCovCtx.lineWidth = 3;
                esikfCovCtx.beginPath();
                
                const maxTrace = Math.max(...esikfCovariance.trace);
                const minTrace = Math.min(...esikfCovariance.trace);
                const range = maxTrace - minTrace || 1;
                
                for (let i = 0; i < esikfCovariance.trace.length; i++) {
                    const x = (i / Math.max(esikfCovariance.trace.length - 1, 1)) * esikfCovarianceCanvas.width;
                    const y = esikfCovarianceCanvas.height - ((esikfCovariance.trace[i] - minTrace) / range) * esikfCovarianceCanvas.height * 0.6 - 20;
                    if (i === 0) {
                        esikfCovCtx.moveTo(x, y);
                    } else {
                        esikfCovCtx.lineTo(x, y);
                    }
                }
                esikfCovCtx.stroke();
                
                // 绘制卡尔曼增益历史（对应数学模型中的K_k）
                if (esikfCovariance.kalmanGain.length > 1) {
                    esikfCovCtx.strokeStyle = '#ff8a8a';
                    esikfCovCtx.lineWidth = 3;
                    esikfCovCtx.beginPath();
                    
                    // 计算卡尔曼增益的最大值和最小值用于缩放
                    let maxGain = 0;
                    let minGain = Infinity;
                    for (let i = 0; i < esikfCovariance.kalmanGain.length; i++) {
                        const gainMagnitude = Math.abs(esikfCovariance.kalmanGain[i].K[0][0]);
                        maxGain = Math.max(maxGain, gainMagnitude);
                        minGain = Math.min(minGain, gainMagnitude);
                    }
                    const gainRange = maxGain - minGain || 0.001;
                    
                    for (let i = 0; i < esikfCovariance.kalmanGain.length; i++) {
                        const gain = esikfCovariance.kalmanGain[i];
                        const x = (i / Math.max(esikfCovariance.kalmanGain.length - 1, 1)) * esikfCovarianceCanvas.width;
                        const gainMagnitude = Math.abs(gain.K[0][0]);
                        const normalizedGain = (gainMagnitude - minGain) / gainRange;
                        const y = esikfCovarianceCanvas.height - normalizedGain * esikfCovarianceCanvas.height * 0.25 - 120;
                        
                        if (i === 0) {
                            esikfCovCtx.moveTo(x, y);
                        } else {
                            esikfCovCtx.lineTo(x, y);
                        }
                    }
                    esikfCovCtx.stroke();
                    
                    // 绘制卡尔曼增益数据点
                    esikfCovCtx.fillStyle = '#ff8a8a';
                    for (let i = 0; i < esikfCovariance.kalmanGain.length; i++) {
                        const gain = esikfCovariance.kalmanGain[i];
                        const x = (i / Math.max(esikfCovariance.kalmanGain.length - 1, 1)) * esikfCovarianceCanvas.width;
                        const gainMagnitude = Math.abs(gain.K[0][0]);
                        const normalizedGain = (gainMagnitude - minGain) / gainRange;
                        const y = esikfCovarianceCanvas.height - normalizedGain * esikfCovarianceCanvas.height * 0.25 - 120;
                        
                        esikfCovCtx.beginPath();
                        esikfCovCtx.arc(x, y, 2, 0, 2 * Math.PI);
                        esikfCovCtx.fill();
                    }
                }
                
                // 绘制创新向量历史（对应数学模型中的ν_k）
                if (esikfCovariance.innovation.length > 1) {
                    esikfCovCtx.strokeStyle = '#96ceb4';
                    esikfCovCtx.lineWidth = 2;
                    esikfCovCtx.beginPath();
                    
                    // 计算创新向量的最大值和最小值用于缩放
                    let maxInnovation = 0;
                    let minInnovation = Infinity;
                    for (let i = 0; i < esikfCovariance.innovation.length; i++) {
                        const innovationMagnitude = Math.sqrt(
                            esikfCovariance.innovation[i].nu[0] * esikfCovariance.innovation[i].nu[0] + 
                            esikfCovariance.innovation[i].nu[1] * esikfCovariance.innovation[i].nu[1]
                        );
                        maxInnovation = Math.max(maxInnovation, innovationMagnitude);
                        minInnovation = Math.min(minInnovation, innovationMagnitude);
                    }
                    const innovationRange = maxInnovation - minInnovation || 0.001;
                    
                    for (let i = 0; i < esikfCovariance.innovation.length; i++) {
                        const innovation = esikfCovariance.innovation[i];
                        const x = (i / Math.max(esikfCovariance.innovation.length - 1, 1)) * esikfCovarianceCanvas.width;
                        const innovationMagnitude = Math.sqrt(innovation.nu[0] * innovation.nu[0] + innovation.nu[1] * innovation.nu[1]);
                        const normalizedInnovation = (innovationMagnitude - minInnovation) / innovationRange;
                        const y = esikfCovarianceCanvas.height - normalizedInnovation * esikfCovarianceCanvas.height * 0.2 - 160;
                        
                        if (i === 0) {
                            esikfCovCtx.moveTo(x, y);
                        } else {
                            esikfCovCtx.lineTo(x, y);
                        }
                    }
                    esikfCovCtx.stroke();
                    
                    // 绘制创新向量数据点
                    esikfCovCtx.fillStyle = '#96ceb4';
                    for (let i = 0; i < esikfCovariance.innovation.length; i++) {
                        const innovation = esikfCovariance.innovation[i];
                        const x = (i / Math.max(esikfCovariance.innovation.length - 1, 1)) * esikfCovarianceCanvas.width;
                        const innovationMagnitude = Math.sqrt(innovation.nu[0] * innovation.nu[0] + innovation.nu[1] * innovation.nu[1]);
                        const normalizedInnovation = (innovationMagnitude - minInnovation) / innovationRange;
                        const y = esikfCovarianceCanvas.height - normalizedInnovation * esikfCovarianceCanvas.height * 0.2 - 160;
                        
                        esikfCovCtx.beginPath();
                        esikfCovCtx.arc(x, y, 1.5, 0, 2 * Math.PI);
                        esikfCovCtx.fill();
                    }
                }
                
                // 绘制曲线图例和标注
                esikfCovCtx.fillStyle = '#ffffff';
                esikfCovCtx.font = '11px Arial';
                esikfCovCtx.fillText('协方差演化与滤波性能指标', 10, 15);
                
                // 绘制曲线图例
                const legendY = 25;
                const legendSpacing = 15;
                
                // 协方差迹曲线图例
                esikfCovCtx.strokeStyle = '#4ecdc4';
                esikfCovCtx.lineWidth = 3;
                esikfCovCtx.beginPath();
                esikfCovCtx.moveTo(10, legendY);
                esikfCovCtx.lineTo(30, legendY);
                esikfCovCtx.stroke();
                esikfCovCtx.fillStyle = '#4ecdc4';
                esikfCovCtx.font = '10px Arial';
                esikfCovCtx.fillText('协方差迹 tr(P_k) - 整体不确定性', 35, legendY + 3);
                
                // 卡尔曼增益曲线图例
                esikfCovCtx.strokeStyle = '#ff8a8a';
                esikfCovCtx.lineWidth = 2;
                esikfCovCtx.beginPath();
                esikfCovCtx.moveTo(10, legendY + legendSpacing);
                esikfCovCtx.lineTo(30, legendY + legendSpacing);
                esikfCovCtx.stroke();
                esikfCovCtx.fillStyle = '#ff8a8a';
                esikfCovCtx.fillText('卡尔曼增益 K_k - 滤波信任度', 35, legendY + legendSpacing + 3);
                
                // 创新向量曲线图例
                esikfCovCtx.strokeStyle = '#96ceb4';
                esikfCovCtx.lineWidth = 2;
                esikfCovCtx.beginPath();
                esikfCovCtx.moveTo(10, legendY + 2 * legendSpacing);
                esikfCovCtx.lineTo(30, legendY + 2 * legendSpacing);
                esikfCovCtx.stroke();
                esikfCovCtx.fillStyle = '#96ceb4';
                esikfCovCtx.fillText('创新向量 ||ν_k|| - 预测与观测差异', 35, legendY + 2 * legendSpacing + 3);
                
                // 绘制实时数值信息
                esikfCovCtx.fillStyle = '#ffffff';
                esikfCovCtx.font = '10px Arial';
                const infoY = legendY + 3 * legendSpacing + 10;
                esikfCovCtx.fillText(`当前 tr(P): ${esikfCovariance.trace[esikfCovariance.trace.length - 1]?.toFixed(3) || 0}`, 10, infoY);
                esikfCovCtx.fillText(`位置不确定性 σ_p: ${Math.sqrt(esikfCovariance.P[0][0]).toFixed(3)}`, 10, infoY + 12);
                esikfCovCtx.fillText(`速度不确定性 σ_v: ${Math.sqrt(esikfCovariance.P[2][2]).toFixed(3)}`, 10, infoY + 24);
                esikfCovCtx.fillText(`姿态不确定性 σ_θ: ${Math.sqrt(esikfCovariance.P[4][4]).toFixed(3)}`, 10, infoY + 36);
                
                // 绘制更新统计信息
                esikfCovCtx.fillStyle = '#e0e0e0';
                esikfCovCtx.font = '9px Arial';
                esikfCovCtx.fillText(`IMU更新: ${esikfIteration}次`, 10, infoY + 50);
                const camUpdates = Math.floor(esikfIteration / Math.floor(parseInt(document.getElementById('esikfIMUFreq').value) / parseInt(document.getElementById('esikfCamFreq').value)));
                esikfCovCtx.fillText(`相机更新: ${camUpdates}次`, 10, infoY + 62);
                
                // 绘制曲线含义说明
                esikfCovCtx.fillStyle = '#cccccc';
                esikfCovCtx.font = '8px Arial';
                const descY = esikfCovarianceCanvas.height - 50;
                esikfCovCtx.fillText('曲线物理含义：', 10, descY);
                esikfCovCtx.fillText('• tr(P_k): 整体不确定性，下降表示滤波收敛', 10, descY + 8);
                esikfCovCtx.fillText('• K_k: 滤波对观测的信任度，值越大越信任观测', 10, descY + 16);
                esikfCovCtx.fillText('• ν_k: 创新向量，反映预测与实际观测的差异', 10, descY + 24);
                esikfCovCtx.fillText('  ν_k = z_k - h(X̂_k)，值越小表示预测越准确', 10, descY + 32);
                esikfCovCtx.fillText('  理想情况下ν_k应呈现白噪声特性，均值为0', 10, descY + 40);
            }
            
            // 绘制参数影响分析面板
            drawESIKFParameterAnalysis();
        }
        
        function drawESIKFParameterAnalysis() {
            if (!esikfVarCtx) return;
            
            esikfVarCtx.clearRect(0, 0, esikfVariableCanvas.width, esikfVariableCanvas.height);
            
            // 获取当前参数值（与数学模型严格对应）
            const f_IMU = parseInt(document.getElementById('esikfIMUFreq').value);  // IMU频率
            const f_cam = parseInt(document.getElementById('esikfCamFreq').value);  // 相机频率
            const sigma_Q = parseFloat(document.getElementById('esikfProcessNoise').value);  // 过程噪声
            const sigma_R = parseFloat(document.getElementById('esikfObsNoise').value);  // 观测噪声
            const P_0 = parseFloat(document.getElementById('esikfInitCov').value);  // 初始协方差
            const N_iter = parseInt(document.getElementById('esikfIterations').value);  // 迭代次数
            
            // 计算参数影响指标（对应数学模型中的性能指标）
            const parameterImpacts = {
                computational_load: (f_IMU / 50) * 0.3 + (f_cam / 10) * 0.2 + (N_iter / 5) * 0.5,  // 计算负荷
                filter_stability: (1 / sigma_Q) * 0.4 + (1 / sigma_R) * 0.3 + (1 / P_0) * 0.3,  // 滤波稳定性
                estimation_accuracy: (f_IMU / 100) * 0.2 + (f_cam / 20) * 0.3 + (N_iter / 10) * 0.3 + (1 / (sigma_Q + sigma_R)) * 0.2,  // 估计精度
                convergence_speed: (f_cam / 10) * 0.4 + (N_iter / 5) * 0.3 + (1 / P_0) * 0.3,  // 收敛速度
                robustness: (sigma_Q / 2) * 0.3 + (sigma_R / 2) * 0.3 + (P_0 / 5) * 0.4  // 鲁棒性
            };
            
            // 绘制参数影响条形图
            const barHeight = 20;
            const barSpacing = 28;
            const startY = 35;
            const maxBarWidth = esikfVariableCanvas.width - 180;
            
            const impacts = [
                { name: '计算负荷', value: parameterImpacts.computational_load, color: '#ff6b6b', unit: '' },
                { name: '滤波稳定性', value: parameterImpacts.filter_stability, color: '#4ecdc4', unit: '' },
                { name: '估计精度', value: parameterImpacts.estimation_accuracy, color: '#45b7d1', unit: '' },
                { name: '收敛速度', value: parameterImpacts.convergence_speed, color: '#96ceb4', unit: '' },
                { name: '鲁棒性', value: parameterImpacts.robustness, color: '#feca57', unit: '' }
            ];
            
            // 绘制面板标题
            esikfVarCtx.fillStyle = '#ffffff';
            esikfVarCtx.font = 'bold 14px Arial';
            esikfVarCtx.fillText('ESIKF参数影响分析', 10, 20);
            
            impacts.forEach((impact, index) => {
                const y = startY + index * barSpacing;
                const barWidth = Math.min(Math.max(impact.value * maxBarWidth, 10), maxBarWidth);
                
                // 绘制条形背景
                esikfVarCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                esikfVarCtx.fillRect(100, y, maxBarWidth, barHeight);
                
                // 绘制条形
                esikfVarCtx.fillStyle = impact.color;
                esikfVarCtx.fillRect(100, y, barWidth, barHeight);
                
                // 绘制条形边框
                esikfVarCtx.strokeStyle = impact.color;
                esikfVarCtx.lineWidth = 1;
                esikfVarCtx.strokeRect(100, y, maxBarWidth, barHeight);
                
                // 绘制标签和数值
                esikfVarCtx.fillStyle = '#ffffff';
                esikfVarCtx.font = '10px Arial';
                esikfVarCtx.fillText(impact.name, 10, y + 14);
                esikfVarCtx.fillText(impact.value.toFixed(2), maxBarWidth + 120, y + 14);
                
                // 绘制百分比标记（放在条形内部）
                const percentage = Math.min(impact.value * 100, 100);
                if (barWidth > 40) {
                    esikfVarCtx.fillStyle = '#000000';
                    esikfVarCtx.font = 'bold 8px Arial';
                    esikfVarCtx.fillText(`${percentage.toFixed(0)}%`, 105 + barWidth/2 - 10, y + 14);
                }
            });
            
            // 检查是否有足够空间显示说明文本
            const remainingHeight = esikfVariableCanvas.height - (startY + impacts.length * barSpacing + 10);
            
            if (remainingHeight > 120) {
                // 绘制简化的指标说明
                const descStartY = startY + impacts.length * barSpacing + 15;
                esikfVarCtx.fillStyle = '#cccccc';
                esikfVarCtx.font = '9px Arial';
                esikfVarCtx.fillText('指标含义：', 10, descStartY);
                
                const shortDescriptions = [
                    '计算负荷-频率&迭代  稳定性-噪声&初始值  精度-综合影响',
                    '收敛速度-相机&迭代  鲁棒性-噪声&不确定性'
                ];
                
                shortDescriptions.forEach((desc, index) => {
                    esikfVarCtx.fillText(desc, 10, descStartY + 12 + index * 10);
                });
                
                // 绘制简化的调节建议
                const adviceStartY = descStartY + 35;
                esikfVarCtx.fillStyle = '#96ceb4';
                esikfVarCtx.font = 'bold 9px Arial';
                esikfVarCtx.fillText('调节建议：', 10, adviceStartY);
                
                esikfVarCtx.fillStyle = '#e0e0e0';
                esikfVarCtx.font = '8px Arial';
                const shortAdvice = [
                    '高精度：↑f_cam,N_iter ↓σ_Q,σ_R   高效率：↓N_iter 适中f_IMU,f_cam',
                    '高鲁棒性：适当↑σ_Q,σ_R,P_0'
                ];
                
                shortAdvice.forEach((adv, index) => {
                    esikfVarCtx.fillText(adv, 10, adviceStartY + 12 + index * 10);
                });
            } else {
                // 空间不足时只显示最基本信息
                const infoY = startY + impacts.length * barSpacing + 10;
                esikfVarCtx.fillStyle = '#cccccc';
                esikfVarCtx.font = '8px Arial';
                esikfVarCtx.fillText('调节参数观察指标变化 | 高精度:↑f_cam,N_iter ↓噪声 | 高效率:↓N_iter', 10, infoY);
            }
            
            // 绘制参数影响说明
            esikfVarCtx.fillStyle = '#ffffff';
            esikfVarCtx.font = '11px Arial';
            //esikfVarCtx.fillText('参数影响分析（对应数学模型性能指标）', 10, 15);
            
            // 绘制当前参数状态
            const currentParams = [
                `f_IMU: ${f_IMU}Hz`,
                `f_cam: ${f_cam}Hz`, 
                `σ_Q: ${sigma_Q}`,
                `σ_R: ${sigma_R}`,
                `P_0: ${P_0}`,
                `N_iter: ${N_iter}`
            ];
            
            esikfVarCtx.fillStyle = '#e0e0e0';
            esikfVarCtx.font = '10px Arial';
            currentParams.forEach((param, index) => {
                const x = 10 + (index % 3) * 80;
                const y = esikfVariableCanvas.height - 40 + Math.floor(index / 3) * 15;
                esikfVarCtx.fillText(param, x, y);
            });
            
            // 绘制实时性能指标
            if (esikfCovariance.trace.length > 0) {
                const currentTrace = esikfCovariance.trace[esikfCovariance.trace.length - 1];
                const positionUncertainty = Math.sqrt(esikfCovariance.P[0][0]);
                
                esikfVarCtx.fillStyle = '#4ecdc4';
                esikfVarCtx.font = '10px Arial';
                esikfVarCtx.fillText(`当前 tr(P): ${currentTrace.toFixed(3)}`, 10, esikfVariableCanvas.height - 10);
                esikfVarCtx.fillText(`位置不确定性: ${positionUncertainty.toFixed(3)}`, 120, esikfVariableCanvas.height - 10);
            }
        }

        function resetESIKFSimulation() {
            esikfRunning = false;
            esikfTime = 0;
            esikfIteration = 0;
            esikfTrajectory = [];
            esikfCovariance.trace = [];
            if (esikfTrajCtx) esikfTrajCtx.clearRect(0, 0, esikfTrajectoryCanvas.width, esikfTrajectoryCanvas.height);
            if (esikfCovCtx) esikfCovCtx.clearRect(0, 0, esikfCovarianceCanvas.width, esikfCovarianceCanvas.height);
        }

        // R3LIVE协同优化仿真变量
        let r3liveRunning = false;
        let lioCanvas, vioCanvas, poseOptCanvas, systemStateCanvas;
        let lioCtx, vioCtx, poseOptCtx, systemStateCtx;
        let r3liveTime = 0;
        let pointCloud = [];
        let cameraTrajectory = [];
        let optimizationErrors = [];
        let systemStates = [];

        function initR3LIVESimulation() {
            lioCanvas = document.getElementById('lioCanvas');
            vioCanvas = document.getElementById('vioCanvas');
            poseOptCanvas = document.getElementById('poseOptCanvas');
            systemStateCanvas = document.getElementById('systemStateCanvas');
            
            if (lioCanvas && vioCanvas && poseOptCanvas && systemStateCanvas) {
                lioCtx = lioCanvas.getContext('2d');
                vioCtx = vioCanvas.getContext('2d');
                poseOptCtx = poseOptCanvas.getContext('2d');
                systemStateCtx = systemStateCanvas.getContext('2d');
                
                lioCanvas.width = lioCanvas.offsetWidth;
                lioCanvas.height = lioCanvas.offsetHeight;
                vioCanvas.width = vioCanvas.offsetWidth;
                vioCanvas.height = vioCanvas.offsetHeight;
                poseOptCanvas.width = poseOptCanvas.offsetWidth;
                poseOptCanvas.height = poseOptCanvas.offsetHeight;
                systemStateCanvas.width = systemStateCanvas.offsetWidth;
                systemStateCanvas.height = systemStateCanvas.offsetHeight;
            }
        }

        function startR3LIVESimulation() {
            if (r3liveRunning) return;
            
            r3liveRunning = true;
            r3liveTime = 0;
            pointCloud = [];
            cameraTrajectory = [];
            optimizationErrors = [];
            systemStates = [];
            
            generateInitialPointCloud();
            runR3LIVEStep();
        }

        function generateInitialPointCloud() {
            const density = parseInt(document.getElementById('pointCloudDensity').value);
            pointCloud = [];
            
            for (let i = 0; i < density; i++) {
                pointCloud.push({
                    x: (Math.random() - 0.5) * 200 + lioCanvas.width / 2,
                    y: (Math.random() - 0.5) * 200 + lioCanvas.height / 2,
                    z: Math.random() * 50,
                    intensity: Math.random() * 255,
                    matched: false
                });
            }
        }

        function runR3LIVEStep() {
            if (!r3liveRunning) return;
            
            const lidarFreq = parseInt(document.getElementById('lidarFreq').value);
            const camFreq = parseInt(document.getElementById('r3liveCamFreq').value);
            const optWeight = parseFloat(document.getElementById('optimizationWeight').value);
            
            r3liveTime += 1.0 / Math.max(lidarFreq, camFreq);
            
            // LIO子系统处理
            processLIOSubsystem();
            
            // VIO子系统处理
            if (Math.floor(r3liveTime * camFreq) > cameraTrajectory.length) {
                processVIOSubsystem(optWeight);
            }
            
            // 协同优化
            performCooperativeOptimization(optWeight);
            
            drawR3LIVEVisualization();
            
            if (r3liveTime < 15.0) {
                setTimeout(() => runR3LIVEStep(), 100);
            } else {
                r3liveRunning = false;
            }
        }

        function processLIOSubsystem() {
            // 模拟LiDAR点云配准
            const currentPose = {
                x: Math.cos(r3liveTime * 0.3) * 50 + lioCanvas.width / 2,
                y: Math.sin(r3liveTime * 0.3) * 50 + lioCanvas.height / 2,
                theta: r3liveTime * 0.3
            };
            
            // 更新点云匹配状态
            for (let point of pointCloud) {
                const dist = Math.sqrt(
                    Math.pow(point.x - currentPose.x, 2) + 
                    Math.pow(point.y - currentPose.y, 2)
                );
                point.matched = dist < 30;
            }
        }

        function processVIOSubsystem(optWeight) {
            // 模拟相机位姿估计
            const noise = (Math.random() - 0.5) * 10;
            const cameraPose = {
                x: Math.cos(r3liveTime * 0.3) * 50 + vioCanvas.width / 2 + noise,
                y: Math.sin(r3liveTime * 0.3) * 50 + vioCanvas.height / 2 + noise,
                theta: r3liveTime * 0.3 + noise * 0.1,
                time: r3liveTime,
                photometricError: Math.abs(noise) * optWeight
            };
            
            cameraTrajectory.push(cameraPose);
        }

        function performCooperativeOptimization(optWeight) {
            // 计算总优化误差
            let lioError = 0;
            let vioError = 0;
            
            // LIO误差
            const matchedPoints = pointCloud.filter(p => p.matched).length;
            lioError = (pointCloud.length - matchedPoints) / pointCloud.length;
            
            // VIO误差
            if (cameraTrajectory.length > 0) {
                vioError = cameraTrajectory[cameraTrajectory.length - 1].photometricError;
            }
            
            const totalError = lioError + optWeight * vioError;
            optimizationErrors.push(totalError);
            
            // 系统状态
            systemStates.push({
                time: r3liveTime,
                lioError: lioError,
                vioError: vioError,
                totalError: totalError,
                matchedPoints: matchedPoints
            });
        }

        function drawR3LIVEVisualization() {
            if (!lioCtx || !vioCtx || !poseOptCtx || !systemStateCtx) return;
            
            drawLIOVisualization();
            drawVIOVisualization();
            drawPoseOptimization();
            drawSystemState();
        }

        function drawLIOVisualization() {
            lioCtx.clearRect(0, 0, lioCanvas.width, lioCanvas.height);
            
            // 绘制点云
            for (let point of pointCloud) {
                lioCtx.fillStyle = point.matched ? '#00ff00' : '#ff6b6b';
                lioCtx.beginPath();
                lioCtx.arc(point.x, point.y, 2, 0, 2 * Math.PI);
                lioCtx.fill();
            }
            
            // 绘制LiDAR位姿
            const currentPose = {
                x: Math.cos(r3liveTime * 0.3) * 50 + lioCanvas.width / 2,
                y: Math.sin(r3liveTime * 0.3) * 50 + lioCanvas.height / 2
            };
            
            lioCtx.fillStyle = '#4ecdc4';
            lioCtx.beginPath();
            lioCtx.arc(currentPose.x, currentPose.y, 8, 0, 2 * Math.PI);
            lioCtx.fill();
            
            // 信息显示
            lioCtx.fillStyle = '#ffffff';
            lioCtx.font = '12px Arial';
            lioCtx.fillText('绿色: 匹配点云', 10, 20);
            lioCtx.fillText('红色: 未匹配点云', 10, 35);
            lioCtx.fillText('青色: LiDAR位姿', 10, 50);
        }

        function drawVIOVisualization() {
            vioCtx.clearRect(0, 0, vioCanvas.width, vioCanvas.height);
            
            // 绘制相机轨迹
            if (cameraTrajectory.length > 1) {
                vioCtx.strokeStyle = '#ff6b6b';
                vioCtx.lineWidth = 2;
                vioCtx.beginPath();
                vioCtx.moveTo(cameraTrajectory[0].x, cameraTrajectory[0].y);
                for (let i = 1; i < cameraTrajectory.length; i++) {
                    vioCtx.lineTo(cameraTrajectory[i].x, cameraTrajectory[i].y);
                }
                vioCtx.stroke();
            }
            
            // 绘制当前相机位置
            if (cameraTrajectory.length > 0) {
                const current = cameraTrajectory[cameraTrajectory.length - 1];
                vioCtx.fillStyle = '#ffaa00';
                vioCtx.beginPath();
                vioCtx.arc(current.x, current.y, 6, 0, 2 * Math.PI);
                vioCtx.fill();
            }
            
            // 信息显示
            vioCtx.fillStyle = '#ffffff';
            vioCtx.font = '12px Arial';
            vioCtx.fillText('红色: 相机轨迹', 10, 20);
            vioCtx.fillText('橙色: 当前位姿', 10, 35);
        }

        function drawPoseOptimization() {
            poseOptCtx.clearRect(0, 0, poseOptCanvas.width, poseOptCanvas.height);
            
            // 绘制优化轨迹对比
            if (cameraTrajectory.length > 1) {
                // 原始轨迹
                poseOptCtx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
                poseOptCtx.lineWidth = 2;
                poseOptCtx.beginPath();
                for (let i = 0; i < cameraTrajectory.length; i++) {
                    const x = (i / cameraTrajectory.length) * poseOptCanvas.width;
                    const y = poseOptCanvas.height / 2 + cameraTrajectory[i].photometricError * 10;
                    if (i === 0) {
                        poseOptCtx.moveTo(x, y);
                    } else {
                        poseOptCtx.lineTo(x, y);
                    }
                }
                poseOptCtx.stroke();
                
                // 优化后轨迹
                poseOptCtx.strokeStyle = '#00ff00';
                poseOptCtx.lineWidth = 2;
                poseOptCtx.beginPath();
                for (let i = 0; i < cameraTrajectory.length; i++) {
                    const x = (i / cameraTrajectory.length) * poseOptCanvas.width;
                    const y = poseOptCanvas.height / 2;
                    if (i === 0) {
                        poseOptCtx.moveTo(x, y);
                    } else {
                        poseOptCtx.lineTo(x, y);
                    }
                }
                poseOptCtx.stroke();
            }
            
            // 信息显示
            poseOptCtx.fillStyle = '#ffffff';
            poseOptCtx.font = '12px Arial';
            poseOptCtx.fillText('红色: 原始位姿', 10, 20);
            poseOptCtx.fillText('绿色: 优化位姿', 10, 35);
        }

        function drawSystemState() {
            systemStateCtx.clearRect(0, 0, systemStateCanvas.width, systemStateCanvas.height);
            
            if (optimizationErrors.length > 1) {
                systemStateCtx.strokeStyle = '#4ecdc4';
                systemStateCtx.lineWidth = 2;
                systemStateCtx.beginPath();
                
                const maxError = Math.max(...optimizationErrors);
                for (let i = 0; i < optimizationErrors.length; i++) {
                    const x = (i / Math.max(optimizationErrors.length - 1, 1)) * systemStateCanvas.width;
                    const y = systemStateCanvas.height - (optimizationErrors[i] / maxError) * systemStateCanvas.height * 0.8;
                    if (i === 0) {
                        systemStateCtx.moveTo(x, y);
                    } else {
                        systemStateCtx.lineTo(x, y);
                    }
                }
                systemStateCtx.stroke();
                
                // 信息显示
                systemStateCtx.fillStyle = '#ffffff';
                systemStateCtx.font = '12px Arial';
                systemStateCtx.fillText(`时间: ${r3liveTime.toFixed(2)}s`, 10, 20);
                systemStateCtx.fillText(`总误差: ${optimizationErrors[optimizationErrors.length - 1]?.toFixed(3) || 0}`, 10, 35);
                if (systemStates.length > 0) {
                    const current = systemStates[systemStates.length - 1];
                    systemStateCtx.fillText(`匹配点: ${current.matchedPoints}`, 10, 50);
                }
            }
        }

        function resetR3LIVESimulation() {
            r3liveRunning = false;
            r3liveTime = 0;
            pointCloud = [];
            cameraTrajectory = [];
            optimizationErrors = [];
            systemStates = [];
            
            if (lioCtx) lioCtx.clearRect(0, 0, lioCanvas.width, lioCanvas.height);
            if (vioCtx) vioCtx.clearRect(0, 0, vioCanvas.width, vioCanvas.height);
            if (poseOptCtx) poseOptCtx.clearRect(0, 0, poseOptCanvas.width, poseOptCanvas.height);
            if (systemStateCtx) systemStateCtx.clearRect(0, 0, systemStateCanvas.width, systemStateCanvas.height);
        }



        document.addEventListener('DOMContentLoaded', function() {
            initCanvas();
            initPhotometricSimulation();
            initESIKFSimulation();
            initR3LIVESimulation();
            
            // 添加参数更新监听器（包括ESIKF参数和R3LIVE光度误差仿真参数）
            ['accNoise', 'gyroNoise', 'imuFreq', 'accBias', 'gyroBias', 'preintTime', 'nodeCount', 'obsNoise', 'optIterations', 'dampingFactor', 'convergenceThreshold', 'stepFactor', 'esikfIMUFreq', 'esikfCamFreq', 'esikfProcessNoise', 'esikfObsNoise', 'esikfInitCov', 'esikfIterations', 'frameCount', 'pixelSetSize', 'refImageNoise', 'transformPerturbation', 'optStepSize'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', function() {
                        const valueSpan = document.getElementById(id + 'Value');
                        if (valueSpan) {
                            valueSpan.textContent = this.value;
                        }
                    });
                }
            });
            
            window.addEventListener('resize', function() {
                if (canvas) {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }
            });
        });
        
        // ESIKF仿真所需的矩阵运算辅助函数（与数学模型严格对应）
        
        // 矩阵乘法：C = A * B
        function matrixMultiply(A, B) {
            const rowsA = A.length;
            const colsA = A[0].length;
            const colsB = B[0].length;
            const C = Array(rowsA).fill().map(() => Array(colsB).fill(0));
            
            for (let i = 0; i < rowsA; i++) {
                for (let j = 0; j < colsB; j++) {
                    for (let k = 0; k < colsA; k++) {
                        C[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return C;
        }
        
        // 矩阵转置：A^T
        function matrixTranspose(A) {
            const rows = A.length;
            const cols = A[0].length;
            const AT = Array(cols).fill().map(() => Array(rows).fill(0));
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    AT[j][i] = A[i][j];
                }
            }
            return AT;
        }
        
        // 矩阵加法：C = A + B
        function matrixAdd(A, B) {
            const rows = A.length;
            const cols = A[0].length;
            const C = Array(rows).fill().map(() => Array(cols).fill(0));
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    C[i][j] = A[i][j] + B[i][j];
                }
            }
            return C;
        }
        
        // 矩阵减法：C = A - B
        function matrixSubtract(A, B) {
            const rows = A.length;
            const cols = A[0].length;
            const C = Array(rows).fill().map(() => Array(cols).fill(0));
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    C[i][j] = A[i][j] - B[i][j];
                }
            }
            return C;
        }
        
        // 单位矩阵：I_n
        function matrixIdentity(n) {
            const I = Array(n).fill().map(() => Array(n).fill(0));
            for (let i = 0; i < n; i++) {
                I[i][i] = 1;
            }
            return I;
        }
        
        // 2x2矩阵求逆：A^{-1}（用于创新协方差矩阵求逆）
        function matrixInverse2x2(A) {
            const det = A[0][0] * A[1][1] - A[0][1] * A[1][0];
            if (Math.abs(det) < 1e-10) {
                // 奇异矩阵，返回伪逆
                return [[1e6, 0], [0, 1e6]];
            }
            
            const invDet = 1.0 / det;
            return [
                [A[1][1] * invDet, -A[0][1] * invDet],
                [-A[1][0] * invDet, A[0][0] * invDet]
            ];
        }
        
        // 矩阵与向量乘法：y = A * x
        function matrixVectorMultiply(A, x) {
            const rows = A.length;
            const y = Array(rows).fill(0);
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < A[i].length; j++) {
                    y[i] += A[i][j] * x[j];
                }
            }
            return y;
        }
        
    </script>
</body>
</html>
